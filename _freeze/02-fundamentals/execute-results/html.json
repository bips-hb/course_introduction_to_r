{
  "hash": "f674859118bfc4c54d430e613a0fc54f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2: R Fundamentals\"\nformat: \n  html:\n    toc: true\neditor: visual\n---\n\n\n\n\n## Hello There!\n\nThis is a Quarto document. It contains regular text, code, and output when viewed in RStudio. It can also be converted into an HTML (or PDF) document, where code and output are shown together as well.\n\nThis text is formatted using *Markdown*, a lightweight syntax that uses asterisks (`*`), underscores (`_`), hyphens (`-`), and parentheses / brackets (`()` and `[]`) to format text. We can also embed images:\n\n![rstudio-overview](assets/img/rstudio-example.png)\n\nWe can also write R code in a code block and execute it using either Ctrl + R like in a regular script or using the green button on the top right of the cell:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Hello\n10 * 5.3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 53\n```\n\n\n:::\n\n```{.r .cell-code}\n-5 + 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n9^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 81\n```\n\n\n:::\n\n```{.r .cell-code}\n2 + 5 / 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.25\n```\n\n\n:::\n\n```{.r .cell-code}\n(2 + 5) / 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.75\n```\n\n\n:::\n:::\n\n\n\n\nThroughout the workshop, we will use this format to interweave text and explanations with code examples. You can modify the code in the blocks and rerun them to see the results, and later we will provide partial code examples where your task will be to complete them to solve a given task.\n\nBefore we try to do any data analysis, we first need to familiarize ourselves with R to know our way around!\n\nIn the example script `01-hello.R` we have already seen that R can be used like a big calculator, and that's already pretty useful. For now, we'll build on that a little.\n\n## Variables and Vectors\n\nWe have seen how to assign values to a variable, such as `age <- 30`. This allows us to re-use data and give it a meaningful(!) name in our work. It becomes more useful when we store not just individual number (*scalars*), but *vectors* of data.\n\nFor example, say we have a small group of patients want to store their basic data, starting with their age:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(30, 33, 31, 29, 40)\n\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30 33 31 29 40\n```\n\n\n:::\n:::\n\n\n\n\nNow `age` is a *vector*, and in R this is the most common type of data structure we deal with. Note that in R, even single numbers like `5` are treated like vectors (of length 1)!\n\nWe can use vectors almost exactly like single numbers for basic math:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35 38 36 34 45\n```\n\n\n:::\n\n```{.r .cell-code}\nage - 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 23 21 19 30\n```\n\n\n:::\n\n```{.r .cell-code}\nage * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120 132 124 116 160\n```\n\n\n:::\n\n```{.r .cell-code}\nage / 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.0 6.6 6.2 5.8 8.0\n```\n\n\n:::\n\n```{.r .cell-code}\nage^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  900 1089  961  841 1600\n```\n\n\n:::\n:::\n\n\n\n\nWhat R here is doing is a form of **vectorization**, by using each element of the vector for the calculation and returning another vector.\n\nWe can also conveniently create sequences of numbers using the colon notation `:`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1 through 10\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# -5 through 5\n-5:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n```\n\n\n:::\n:::\n\n\n\n\nIf we add vectors of the same length, R will try to add each element separately:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30 33 31 29 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# Same length: ok\nage + 1:5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31 35 34 33 45\n```\n\n\n:::\n\n```{.r .cell-code}\n# not same length: not ok\nage + 1:7\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in age + 1:7: longer object length is not a multiple of shorter object\nlength\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31 35 34 33 45 36 40\n```\n\n\n:::\n:::\n\n\n\n\nBut what happens here?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage + 1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 31 35 34 33 45 36 40 39 38 50\n```\n\n\n:::\n:::\n\n\n\n\nThis is called **recycling** and can be great *or* introduce unexpected behavior if it happens by accident!\n\nA simpler example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(5, 5, 5, 5, 5, 5)\nx + c(-1, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4 6 4 6 4 6\n```\n\n\n:::\n:::\n\n\n\n\n### Your turn: Creating vectors & variables\n\n1.  Create a vector containing the letters \"A\", \"B\", \"C\", \"D\".\n2.  Create a vector containing the decimal numbers 1.2, 4.7, 9.4.\n3.  Create a vector containing the integers from 10 to 1 in descending order and without writing out the elements.\n4.  Create a vector containing a sequence from 10 to 40 in steps of 10, without writing out the elements. Using Google, can you find a function to achieve the same result?\n5.  Assign the vectors `(1.2, 3.4)` and `(3.6, 5.7)` to the variables `x` and `y`. Combine these into a single vector `z = (1.2, 3.4, 3.6, 5.7)` without writing out the individual elements / numbers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. vector ABCD\nc(\"A\", \"B\", \"C\", \"D\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A\" \"B\" \"C\" \"D\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2.\nc(1.2, 4.7, 9.4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 4.7 9.4\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3.\n10:1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n\n\n:::\n\n```{.r .cell-code}\n# 4.\n1:4 * 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(from = 10, to = 40, by = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n\n```{.r .cell-code}\n# 5.\nx <- c(1.2, 3.4)\ny <- c(3.6, 5.7)\nz <- c(x, y) \n# Identical to\nz <- c(1.2, 3.4, 3.6, 5.7)\n```\n:::\n\n\n\n\n### Your turn: Working with variables\n\nLet's assume more patient data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheight_cm <- c(184, 174, 171, 179, 180)\nweight_kg <- c(75, 64, 70, 85, 78)\n```\n:::\n\n\n\n\n1.  Using the variables above, calculate the BMI for each patient.\n2.  Store the result in a variable called `bmi`. Keep in mind you can use parentheses to group calculations like in a calculator, e.g. `(x + 4) * y`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheight_cm <- c(184, 174, 171, 179, 180)\nweight_kg <- c(75, 64, 70, 85, 78)\n\nweight_kg/height_cm^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.002215265 0.002113886 0.002393899 0.002652851 0.002407407\n```\n\n\n:::\n:::\n\n\n\n\n## Functions\n\nOn vectors, we can use additional functions common in statistics and data analysis:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32.6\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# variance\nvar(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26.3\n```\n\n\n:::\n\n```{.r .cell-code}\n# standard deviation (root of variance)\nsd(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.128353\n```\n\n\n:::\n\n```{.r .cell-code}\n# inter-quartile range\nIQR(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\n# minimum and maximum\nrange(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 171 184\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of elements (length) of the vector\nlength(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Sum of all elements\nsum(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 888\n```\n\n\n:::\n\n```{.r .cell-code}\n# Handy \"common statistics\" summary\nsummary(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  171.0   174.0   179.0   177.6   180.0   184.0 \n```\n\n\n:::\n:::\n\n\n\n\nFunctions can take *arguments* which specify further options, always separated by a comma `,`. Example: To calculate the quartiles of a vector without `summary()`, we take the function `quantile()` to calculate the 25%, 50%, and 75% quartiles:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nquantile(height_cm, probs = c(0.25, 0.5, 0.75))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n25% 50% 75% \n174 179 180 \n```\n\n\n:::\n:::\n\n\n\n\nNote that function arguments are always declared with the `=` character! We will learn more about function arguments later.\n\n### Your turn\n\n*Without* using the function `mean` or `summary`, calculate the mean height (`height_cm`) using the other available functions.\n\nHint: The mean is defined as the sum of the values divided by the number of entries.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(height_cm)/length(height_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 177.6\n```\n\n\n:::\n:::\n\n\n\n\n## Vector Types\n\nSo far we have seen numeric values only, but there are other useful types we will need down the road, and maybe a detail that might be good to know.\n\nIn R, there are these basic types:\n\n-   Numeric for numbers:\n    -   `10`, `-3.2`, and the value of `pi`\n-   Character for text:\n    -   `\"hello\"`, `\"a\"` and `\"\"` (an empty string)\n-   Logical (also \"boolean\"):\n    -   Either `TRUE` or `FALSE`\n\nWhen we create a vector, it can only be of *one* type!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Numeric vector\nc(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# Character vector\nc(\"1\", \"a\", \"v\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"a\" \"v\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Also become a character vectors!\nc(1, 2, \"3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(1, TRUE, FALSE, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"     \"TRUE\"  \"FALSE\" \"a\"    \n```\n\n\n:::\n:::\n\n\n\n\n**\"Numeric\"** is technically a class further separated into whole numbers (*integers*) and decimal numbers. The latter are referred to as \"floating point numbers\" and the type is called \"*double*\" for boring history-of-computing reasons. Usually a numeric vector in R is a double, unless explicitly denoted an integer. You can check the difference with the function `typeof()`, e.g. `typeof(3)`\n\nThe important bit is that they have upper and lower limits because computers can't store numbers with arbitrary precision:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10^3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000\n```\n\n\n:::\n\n```{.r .cell-code}\n10^10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1e+10\n```\n\n\n:::\n\n```{.r .cell-code}\n10^100\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1e+100\n```\n\n\n:::\n\n```{.r .cell-code}\n10^1000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n# Too close to zero\n10^-1000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nThe `e` here is for \"exponent\" and `1e5` is identical to `1 * 10^5`, and `2e-3` is `2 * 10^-3` or `0.002`.\n\n**Integers** are sometimes used explicitly, and we write them like so: `1L` (the \"L\" has weird historic reasons). It can be useful to use integers explicitly, or to be aware of your data being in integer format rather than double.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n\n\n**Characters** are useful for text and categorical information, for example to denote regions of origin in a dataset:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinents <- c(\"Europe\", \"North America\", \"East Asia\")\n```\n:::\n\n\n\n\nFor **logicals** it's important to note that `TRUE` and `FALSE` are reserved words, so you can't use them as variable names.\n\n::: callout-note\nSome `\"character\"`-related things to keep on the \"I know where to look it up\" pile:\n\n-   `c(\"apples\", \"oranges\")` is a *character vector* of length 2. You might encounter the notation `character(2)` to refer to this type and length\n-   A character vector has a *length* just like any other vector retrievable with `length(x)`\n-   If you want to know the *number of characters* in a character vector, use `nchar(x)`\n-   `nchar(c(\"apples\", \"oranges\"))` gives you the number of characters for each string!\n:::\n\n### Changing Types\n\nIn many cases we can change the type of a vector from one to another, but only if it is *meaningful* to do so.\n\nFor example, we can use `as.character()` to turn any numeric vector into a character vector and we will be able to convert it back with `as.numeric()`, but if we start with a character vector like `c(\"apples\", \"bananas\")`, there's no meaningful way to convert it to a numeric vector!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.character(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(as.character(1:5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nas.numeric(c(\"apples\", \"bananas\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA NA\n```\n\n\n:::\n:::\n\n\n\n\n### Your Turn\n\n1.  Create vectors of the types integer, double, character and logical\n2.  Experiment with the functions `as.numeric`, `as.integer`, `as.double`, `as.character`, `as.logical`\n\n## Missing data\n\nAt some point in your analysis, you will always encounter missing data. Whether it's measurement error or a partial survey response, there's no way to avoid it.\n\nIn R, missing values are denoted `NA`, for \"Not Available\". It's important to note that there is absolute *no* information, so we can not do **anything** with missing values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vector with missing value\nage <- c(30, 32, 38, 27, NA, 27, 29, NA, 30, 31)\n\nmean(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\n\n\nThe missing value(s) could be *anything*, so R is cautious and refuses to give you any sort of answer!\n\nWhat do we do with that?\n\n## The Help\n\nWe really want the mean of the age here, but we don't want to exclude an entire patient from our dataset.\n\nWe can check R's built-in **help system** by adding a `?` in front of any function name (without parentheses). Try it out using the `mean` function!:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\n```\n:::\n\n\n\n\nA help page always has the same format:\n\n-   The **name** of the function or help page topic\n-   **Description** tells you what it does\n-   **Usage** shows you what other *arguments* the function has, followed by...\n-   **Arguments** explaining each one in more detail\n-   **Value** tells you what the function returns, like `mean()` returning a scalar, but `range()` returning a vector with 2 values\n-   **Examples** show you concrete code examples that you can usually copy and paste into the console to see the function in action! This where we hope the developer has taken the time to provide good examples :)\n\n### Your turn\n\n-   Calculate the mean of the `age` variable above with the missing value, using the `mean` function (Remember the name of the relevant argument - it will come up often!)\n-   What else can `mean` do that might be useful sometimes?\n-   Also calculate the median and variance of `age`\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nBonus:\n\n-   Look at the help page of `table()`. It looks a little different in the \"Usage\" part\n\n## More Vector-Work\n\nNow we can already do many things with vectors, but there is one important thing missing:\\\nWe can't access individual elements or ranges yet. In R, we do that using square brackets with an index number: `x[1]` gives us the first element of `x`.\n\nSome examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 11:20\n\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nx[5:7]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15 16 17\n```\n\n\n:::\n\n```{.r .cell-code}\nx[c(1, 2, 6)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11 12 16\n```\n\n\n:::\n:::\n\n\n\n\nThis is called *indexing* a vector and it's one of the most common operations!\n\nWe will practice this later, but before we do...\n\n### A Little Logic Crash Course\n\nWe spoke of logical values before, and it's time to get to know them a little better!\n\nOne of the most common applications is in **comparisons**, i.e., is `x` greater, equal, or less than `y`? In R, we can do these comparisons using *logical operators*:\n\n-   `x ==` **Equals** (two `=` signs without space in between)\n-   `x !=` **Not Equal** (Exclamation point and `=` without space in between)\n-   `x > y` and `x < y` **Greater** and **Less than** (left and right angle brackets)\n-   `x >= y` and `x <= y` **Greater or equal** and **Less than or equal** (angle brackets with `=`)\n-   `x %in% y` is `x` **in** `y`?\n\nAny statement such as `x == y` or `a < b` results in a logical value: `TRUE` or `FALSE`.\n\nfor example for some fictitious weight data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight_kg <- c(75, 64, 71, 45, 85, 78, 101, 94, 62, 70, 52)\n\nweight_kg > 60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nweight_kg == 101\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nweight_kg < 75\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n85 %in% weight_kg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nThese can be combined using\n\n-   `&` **AND**: `a & b` is `TRUE` if and only if both `a` and `b` are `TRUE` and otherwise `FALSE`\n-   `|` **OR**: `a | b` is `TRUE` if *either* `a` *or* `b` is `TRUE` and `FALSE` if both are `FALSE`\n\nOne of the most common things to do in data analysis is to filter data based on logical comparisons, such as \"patients with blood pressure over a certain threshold\" or \"patients who are male and older than 65\".\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight_kg < 60 | weight_kg > 90\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n```\n\n\n:::\n:::\n\n\n\n\nIt can be useful to turn the `TRUE` and `FALSE`s into the index positions of the vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight_kg == 101\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich(weight_kg == 101)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\nThis tells us the 7th element is the one with the value `101`.\n\nWe can also use functions for help, like finding out which position in the vector is the smallest or largest\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(weight_kg == min(weight_kg))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nwhich(weight_kg == max(weight_kg))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n\n\nThis is so useful that R has functions for that, see `?which.min`\n\n### Vector Indexing\n\nNow we have all the tools we need to slice and dice our vectors! Because with the `x[<index>]` notation for vector subsetting (indexing), we can also use *logical* values, which is very powerful!\n\nif we use a logical vector for indexing, R will give us all the elements of the vector for which the index was`TRUE` and omit those that were `FALSE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweight_kg <- c(75, 64, 71, 45, 85, 78, 101, 94, 62, 70, 52)\n\nweight_kg[weight_kg < 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 45 52\n```\n\n\n:::\n\n```{.r .cell-code}\nweight_kg[weight_kg > 85]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 101  94\n```\n\n\n:::\n\n```{.r .cell-code}\nweight_kg[weight_kg < 60 | weight_kg > 80]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  45  85 101  94  52\n```\n\n\n:::\n:::\n\n\n\n\nNote that using some of the functions from earlier we can already do some simple analysis by just counting, which is easy for logical values because `sum()` treats `TRUE` like a `1` and `FALSE` like a `0`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(weight_kg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(weight_kg < 60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(weight_kg < 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\n\nWe can also change parts of a vector like this, like changing the 4th element to the value of 20:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nx[4] <- 20\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  3 20  5\n```\n\n\n:::\n:::\n\n\n\n\n### Your turn\n\nUsing the `weight_kg` variable above, subset it to find out...\n\n1.  How many values are smaller than the mean weight?\n2.  How many are between 30 and 70?\n3.  How many are between the 20% and 75% quantile?\n4.  If we define outliers as those outside the 10% and 90% quantile, do we find any outliers?\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nAnother useful indexing function is `is.na()`, which tells you whether a value is `NA` or not.\\\nRemember the `age` variable before?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(30, 32, 38, 27, NA, 27, 29, NA, 30, 31)\n```\n:::\n\n\n\n\n5.  Find the index positions of the `NA` values\n6.  Replace the `NA` values with the mean age when missing values are ignored\n\n## Appendix: Useful Functions for Vectors\n\nLike with every language, there is always a certain set of vocabulary you'll just have to learn and remember. The next best thing is of course knowing where to look them up.\n\nIn that regard, here is a list of common function which might come in handy at some point!\\\nRemember to use the help with `?function` to learn more (or use Google, or ChatGPT, or whatever works!)\n\n-   `c()` combines values into vectors. Can also combine multiple vectors into one!\n-   `round()` to round values to some number of digits.\n-   `length()` for the number of elements\n-   `unique()` removes any duplicates\n    -   `anyDuplicated` tells you if there are duplicates in the first place\n\n### Types\n\n-   `as.character()`, `as.numeric()`, `as.integer()` and `as.logical()` convert types\n-   `is.character()`, `is.numeric()`, `is.integer()` and `is.logical()` *check* types\n-   `class()` and `typeof()` tell you what the vector is (the details are technical and not too important for now)\n\n## Math Operators\n\n-   `+`, `-` for addition and subtraction\n-   `*`, `/` for multiplication and division\n-   `2^6`, `log(64, base = 2)` for exponentiation and logarithms\n-   `%%` modulo, i.e. division with rest\n\n### Describing Data\n\n-   `summary()` gives you a list of statistics for a vector (and also works on other types of objects we'll see later!)\n-   `table()` gives you a frequency table, or a simple 2x2 table if you supply two vectors\n-   `quantile(..., probs = ...)` for quantiles at probabilities given as `probs`\n-   `mean()`, `median()` give you what you'd expect\n-   `var()` for variance and `sd()` for the standard deviation\n-   `min()` and `max()` for minimum and maximum of a vector, `range()` for both\n-   `sum()` for the sum of a vector, see also it's lesser known sibling, `diff()`\n-   `cumsum()` the cumulative sum, so a vector of the same length but each element is the sum of all previous elements\n\n### Sequences\n\n-   `seq()` creates sequences from whicher start, end, and step size you provide\n-   `a:b` also creates sequences, but always from `a` to `b` in steps of 1\n-   `seq_len()` creates a sequence from 1 to whatever you provide - a shortcut for `1:n`\n-   `rep()` repeat elements to form a vector, e.g. `rep(c(1, 0), times = 3)`\n\n### Random Numbers / Probability Distributions\n\nR is first and foremost a statistical language, and as such it has great facilities for working with random number sand probability distributions. These functions come in 4 versions with different first letters for\n\n-   `r` to draw **r**andom numbers\n-   `d` for values from a probability **d**istribution\n-   `p` for **p**robabilities\n-   `q` for **q**uantiles of a distribution\n\nfollowed by the type of distribution, e.g.\n\n-   `unif` for the uniform distribution\n-   `norm` for the normal distribution\n-   `binom` for the Binomial distribution\n-   `pois` for the Poisson distribution\n\nso for the normal distribition, we have the functions `rnorm()`, `dnorm()`, `pnorm()` and `qnorm()`.\n\nSome examples:\n\n-   `rnorm(10, mean = 100, sd = 15)` 10 normally distributed numbers with mean 15 and SD of 5\n-   `dbinom(4, size = 10, prob = 0.5)` probability of 4 successes after 10 trials with a probability of 0.5 for a Binomial event (like coin flips)\n-   `pbirthday(20, classes = 365, coincident = 2)` probability of two people sharing the same birthday in a group of 20\n\nSee also `?Distributions`\n",
    "supporting": [
      "02-fundamentals_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}