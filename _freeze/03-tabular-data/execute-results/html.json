{
  "hash": "ef66269e6efb915020fa496bcee06875",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"3: Tabular Data\"\nformat: \n  html:\n    toc: true\neditor: source\n---\n\n\n\n\nSo far we have used individual vectors as data, but of course it is not particularly convenient to work with real data like that. Whether your data originally is stored in an Excel file or some sort of database system, it is usually stored in a *tabular* format, ideally with two key properties:\n\n1.  Each **column** of your data is a **variable** (like age, weight, ...)\n2.  Each **row** of your data is an **observation** (like a single patient, a hospital, a country, ...)\n\nIn the real world, data tends to come in all shapes and sizes, but for the purposes of analysis this is the shape to strive for.\n\nJust like we made up some patient data to store as vectors, we can use the same approach to create tabular data, using the `data.frame()` function. Each argument of this function takes a *vector* just like we used before, so in a sense the `data.frame` is just a way to organize vectors that all must have the same length!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df <- data.frame(\n  id = 1:5,\n  age = c(35, 32, 26, 40, 34),\n  weight_kg = c(75, 64, 71, 45, 85)\n)\n\nexample_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id age weight_kg\n1  1  35        75\n2  2  32        64\n3  3  26        71\n4  4  40        45\n5  5  34        85\n```\n\n\n:::\n:::\n\n\n\n\n## Working with Tabular Data\n\nWe manipulated vectors by indexing them with `[ ]`, things are more complicated with `data.frames` but fundamentally the idea is the same!\n\nWe can access individual **columns** of the data.frame like the vectors they are using either `$` or *double* brackets for indexing `[[ ]]` where the index can be the integer index or *the name* of the variable, so these are all identical and result in a vector:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df$age\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35 32 26 40 34\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35 32 26 40 34\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df[[\"age\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35 32 26 40 34\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df$id\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df$weight_kg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 75 64 71 45 85\n```\n\n\n:::\n:::\n\n\n\n\nSince this gives us a vector, we can do the usual vector things:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First 5 age values\nexample_df$age[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35 32 26 40 34\n```\n\n\n:::\n\n```{.r .cell-code}\n# All age values under 30\nexample_df$age[example_df$age < 30]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26\n```\n\n\n:::\n\n```{.r .cell-code}\n# 2nd column, 3rd element\nexample_df[[2]][3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26\n```\n\n\n:::\n:::\n\n\n\n\nThis becomes inconvenient really quickly though, which is why there are better ways we'll see soon.\n\nNote that this way we can only ever get *one* vector, so this does **not work** as we might expect:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df[[c(1, 2)]]\nexample_df[[c(\"id\", \"age\")]]\n```\n:::\n\n\n\n\nWe can however use single brackets to access one *or more* columns, rows, or both, and it get's a little more complex:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First column, result is a data.frame\nexample_df[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id\n1  1\n2  2\n3  3\n4  4\n5  5\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df[\"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id\n1  1\n2  2\n3  3\n4  4\n5  5\n```\n\n\n:::\n\n```{.r .cell-code}\n# 3rd row\nexample_df[3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id age weight_kg\n3  3  26        71\n```\n\n\n:::\n\n```{.r .cell-code}\n# First column, 5th row\nexample_df[5, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df[5, \"id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n:::\n\n\n\n\nWhen we use single brackets, the result is still a `data.frame` unless in the last case where the result is a scalar. This can become somewhat tricky, but if you *insist* on the result being a `data.frame` you can add `drop = FALSE`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df[5, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5\n```\n\n\n:::\n\n```{.r .cell-code}\nexample_df[5, 1, drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id\n5  5\n```\n\n\n:::\n:::\n\n\n\n\nThis is a \"good to know and easy to forget\" bit of information. Soon we will introduce mechanisms to make working with tabular data a bit more intuitive, but since you will most likely encounter this type of code in the wild, we'll practice it a little soon.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df[example_df$age >= 30, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  id age weight_kg\n1  1  35        75\n2  2  32        64\n4  4  40        45\n5  5  34        85\n```\n\n\n:::\n:::\n\n\n\n\n## External Data\n\n### Built-in\n\nR comes with some built-in datasets that are \"just there\":\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsleep\nmtcars\niris\n```\n:::\n\n\n\n\nThey are built-in in the sense that they are part of the R installation - you can not accidentally delete them and you don't need to do anything special to access them, which makes them the standard case for tutorials and examples --- and of course also a little boring!\n\nWe can also install packages that provide additional data, and many packages that provide some sort of statistical or visualization functionality often include toy datasets to illustrate their use.\\\nWe'll see examples of that later as well!\n\n### Reading and Writing Data from/to Files\n\nA usual part of the workflow is to import data, clean it up, modify it in some way, and then storing it as a file for later use or to share it with collaborators.\n\nThere are many formats we could use, and they vary in how simple they are to use within R, how easy it is to read them with other software, and how certain you want to be that people are going to be able to read the data in 30 years.\n\nFor simplicity we'll focus on two kinds of formats: R's built-in format `RDS`, and plain-text delimited formats like CSV and TSV.\n\n#### RDS\n\nRDS has the benefit of being able to losslessly store any kind of R objects, which means that whatever you store as a file on your computer you'll most likely be able to just read into R again and use it as if nothing happened.\\\nThis is why RDS is the most popular for \"within R\" workflow where you want to store intermediate results for example, or cleaned datasets you want to use later for analysis in a different R project.\n\nWe can store and restore data to RDS like this, using the `example_df` and the `data` directory in this project:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/Users/Lukas/repos/github/bips-hb/course_introduction_to_r\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsaveRDS(example_df, file = \"data/example_df.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_rds <- readRDS(file = \"data/example_df.rds\")\n```\n:::\n\n\n\n\nWe can check if the two are identical:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(example_df, example_rds)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n1.  Create a data.frame called `test_df`with 3 variables\n2.  Save to `data/test.rds`\n3.  Read it back and name the variable `read_test`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df <- data.frame(\n  letter = c(\"A\", \"B\", \"C\", \"hello\"),\n  height_cm = c(123, 346, 123, 7457),\n  logical = c(TRUE, FALSE, TRUE, TRUE)\n)\ntest_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  letter height_cm logical\n1      A       123    TRUE\n2      B       346   FALSE\n3      C       123    TRUE\n4  hello      7457    TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsaveRDS(test_df, file = \"data/test.rds\")\nread_test <- readRDS(file = \"data/test.rds\")\n\nidentical(test_df, read_test)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\n### CSV\n\nComma separated values (CSV) are maybe the most common way to share data that's not large enough to require database or strong compression. If you want to share data in a way that others can import it into Excel without a big headache, this is probably the way to go!\\\nAlso if you want to make sure that your great-great-great-grandchildren are still able to read your data without any special software.\n\nIt's the lowest common denominator in many ways, and it can be very annoying to deal with.\n\nIn the simplest case we can read and write CSVs with `read.csv()`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(example_df, file = \"data/example_csv123.csv\", \n          row.names = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_csv <- read.csv(file = \"data/example_csv123.csv\")\n```\n:::\n\n\n\n\nNote that `?read.csv` and `?write.csv` show a few option that will be useful at some point, like `sep`. By default, we write and read comma-delimited files, but we could also do `sep = \";\"` to use `;` as a separating character!\\\nWhen you try to read data with Excel for example, then using `;` might make things easier.\n\nWhen it comes to reading external data, tons of things can go wrong and for now, we just assume that it went okay.\n\nFor future reference though:\n\n-   When in doubt, google around for how to best read the given data into R\n-   Ensure to glance at the relevant documentation, e.g. for `?read.csv`, if you run into errors or unexpected behavior\n-   Once you're used to installing packages, the `readr` package might be of interest here\n-   Refer to [this chapter in R4DS](https://r4ds.hadley.nz/import) for more information and examples!\n-   The package `haven` has functions to read and write data in formats used by SAS and SPSS\n\n::: callout-tip\nTo keep a project organized, it's good practice to\n\n-   Store original, raw data in a dedicated directory like `data-raw` and **never modify it**!\n-   Read it, clean it, and store a clean version of your data in `data`\n\nThat way, you should always your original data, your final data, and most importantly: Reproducible R code you can share with others that explains how to get from point A to point B!\n:::\n\n## Excursion: Packages\n\nBefore we move on, it's time to take a look at this open source ecosystem we mentioned in the beginning. In R, this mostly means we can install *packages*. A package is a collection of functions and sometimes other objects which we can use for additional capabilities, and lets us benefit from other people's work such that we don't have to reinvent the wheel every time we do an analysis.\n\nWe can install packages using either RStudio's \"Packages\" pane to the right, or we can use R functions directly.\n\nFor example, there is a package called `\"readxl\"` which allows us to Excel files (`.xlsx`), and we can install it like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"readxl\")\n```\n:::\n\n\n\n\nWe can then **load** the package using the `library()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\n```\n:::\n\n\n\n\nWe can now use functions from the package, and if we don't know where to start, usually `?readxl` is a good entrypoint.\n\nKeep in mind:\n\n1.  You *have to* **install** a package *once* into your package \"library\"\n2.  You *have to* **load** the package every time you restart R\n3.  You *should* occasionally **update** your installed packages using `update.packages(ask = FALSE)`.\n\nAs an example for what we would use `readxl` for, let's read an example dataset stored on `data-raw` in this folder in the `.xlsx` format.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df <- readxl::read_excel(path = \"data-raw/example.xlsx\")\n```\n:::\n\n\n\n\nHere, the function `read_excel()` is provided by the package `readxl` and only available when that package is installed and loaded! An error message like\n\n```         \ncould not find function \"read_excel\"\n```\n\nindicated that you either have not loaded the required package or maybe mistyped the function name.\n\n::: callout-note\nOnce a package is installed, it is also possible to use one of its functions without loading it beforehand by using the `::` syntax, like `readxl::read_excel()`\n\nWe won't do that here yet, but in the wild you might find people referring to a function in the format `somePackage::some_fun()` to clarify they mean `some_fun()` from the package `somePackage`!\n:::\n\n### Your Turn\n\nWe will now move on to using more packages, which of course first need installation. Unless you have already done so, install the following packages:\n\n-   \"tidyverse\"\n-   \"gapminder\"\n-   \"gtsummary\"\n-   \"table1\"\n-   \"ggstatsplot\"\n-   \"ggthemes\" \n-   \"readr\"\n\n**Alternatively** you can install the package `pak` first, and then install the packages above using `pkg_install()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pak)\npkg_install(\"tidyverse\")\n```\n:::\n\n\n\n\n`pak` should be a bit faster and depending on your operating system also more robust, and it brings a few features not relevant yet.\\\nIf you use a Linux distribution like Ubuntu, `pak` can save you a lot of annoyances.\n\nIn any case, this might take a moment!\n\n## Knowing Your Data\n\nAs mentioned, accessing tabular data is a bit more complex than it is for vectors, and in the next section we will learn about convenient tools for this case. However, there are some common built-in tools that R provides for this which you should be at least aware of.\n\nWe'll start with a new dataset from one of the packages you just installed: `gapminder` This dataset is based on the [Gapminder](https://www.gapminder.org/) data, and also part of [Hans Rosling's almost 20 year old TED talk](https://www.ted.com/talks/hans_rosling_the_best_stats_you_ve_ever_seen).\n\nFirst we *load the data* which in this case means to just load the `gapminder` package to access the dataset with the same name (confusingly so)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gapminder)\ngapminder\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe can also view the dataset in RStudio with `View()`, and look at its documentation with `?`:\n\n``` r\nView(gapminder)\n?gapminder\n```\n\nTo see the number of rows and columns, we can use `nrow()`, `ncol()`, or `dim()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1704\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ndim(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1704    6\n```\n\n\n:::\n:::\n\n\n\n\nWe often want to see the first or last few rows using `head()` and `tail()` (note: these also work on vectors!)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n```\n\n\n:::\n\n```{.r .cell-code}\ntail(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  <fct>    <fct>     <int>   <dbl>    <int>     <dbl>\n1 Zimbabwe Africa     1982    60.4  7636524      789.\n2 Zimbabwe Africa     1987    62.4  9216418      706.\n3 Zimbabwe Africa     1992    60.4 10704340      693.\n4 Zimbabwe Africa     1997    46.8 11404948      792.\n5 Zimbabwe Africa     2002    40.0 11926563      672.\n6 Zimbabwe Africa     2007    43.5 12311143      470.\n```\n\n\n:::\n:::\n\n\n\n\nWe can also use `str()` to get a basic overview of the data, including each variables type:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n```\n\n\n:::\n:::\n\n\n\n\nDon't forget we can also refer to the documentation using `?gapminder` to learn about what each variable means!\n\nThere is also something new there: A type of data we have not encountered before: The `factor`! `factors` are for *categorical data*, particularly the kind where we know beforehand how many different categories there are and what they are called.\n\nA quick example:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit <- factor(c(\"apple\", \"lemon\", \"apple\"))\nfruit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] apple lemon apple\nLevels: apple lemon\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\" \"lemon\"\n```\n\n\n:::\n:::\n\n\n\n\nWe can set the `levels` of a factor manually or change them later.\\\nA `factor` can have a level that does not appear on the data, but it will \"know\" that there is an extra category, which helps us keep an overvoew on what we expect!\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit <- factor(\n   c(\"orange\", \"apple\", \"apple\", \"orange\", \"apple\", \"orange\"), \n   levels = c(\"apple\", \"banana\", \"orange\")\n)\nfruit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] orange apple  apple  orange apple  orange\nLevels: apple banana orange\n```\n\n\n:::\n\n```{.r .cell-code}\nlevels(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"apple\"  \"banana\" \"orange\"\n```\n\n\n:::\n:::\n\n\n\n\nThe `table()` function gives us a simple frequency table of the data, and since it expects there to be `\"banana\"`, it shows us a frequency of 0:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(fruit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfruit\n apple banana orange \n     3      0      3 \n```\n\n\n:::\n\n```{.r .cell-code}\nfruit_char <- c(\"orange\", \"apple\", \"apple\", \"orange\", \"apple\", \"orange\")\n\ntable(fruit_char)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfruit_char\n apple orange \n     3      3 \n```\n\n\n:::\n:::\n\n\n\n\n`factors` are like `characters` but with *additional information* stored in them, and dealing with them can be a bit counter-intuitive. For now, we're happy with knowing that they exists and that they are useful for categorical data!\n\nIn `gapminder`, there are two `factor` variables as we have seen using `str()`: `country` and `continent`.\n\nWe can use the aforementioned `table()` to get a broad overview of what we are dealing with\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(gapminder$continent)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n```\n\n\n:::\n:::\n\n\n\n\nWe will get a better overview later, but for now we'll practice the basics for a moment\n\n### Your Turn\n\nUsing the `gapminder` data, try to find out the following:\n\n1.  Select the variables `country`, `pop` and `lifeExp`\n2.  Filter the dataset to the year 2007\n3.  For the country of *Mauritius*, what is the population in the year 1997?\n4.  How many different countries are in the dataset?\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\nHint: The function `unique()` is similar to `levels()` for factors, but more general -- both can be combined with `length()`!\n",
    "supporting": [
      "03-tabular-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}