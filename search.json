[
  {
    "objectID": "06-whole-game.html",
    "href": "06-whole-game.html",
    "title": "5: The Whole Game",
    "section": "",
    "text": "By now we have enough useful tools at our disposal practice an exploratory analysis:\nWe will first go through these steps and then build on them by introducing additional tools for statistical reporting, but throughout this last piece of the course there will be fewer code examples and more room for you to experiment! This will take some time, so don’t worry if you don’t get everything down right the first time or if we don’t finish this chapter before the end of the course.\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "06-whole-game.html#importing-data",
    "href": "06-whole-game.html#importing-data",
    "title": "5: The Whole Game",
    "section": "Importing Data",
    "text": "Importing Data\nSo far we have played with example data and the gapminder data, but now it’s time to start with something fresh and unfamiliar.\nThe dataset we’ll explore is called “chemo”, and you can find it in the data-raw directory in these workshop materials. It is stored as a CSV file called \"chemo.csv\", and to import it you could use the built-in function read.csv(), but to be more tidyverse-focused we’ll use the readr package and the read_csv() function, which is a tad more flexible and more user-friendly. We’ll give it the name chemo from here on out!\n\nchemo &lt;- readr::read_csv(\"data-raw/chemo.csv\")\n\nRows: 200 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): trt, stage, grade\ndbl (5): age, marker, response, death, ttdeath\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nchemo\n\n# A tibble: 200 × 8\n   trt      age marker stage grade response death ttdeath\n   &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;\n 1 Drug A    23  0.16  T1    II           0     0    24  \n 2 Drug B     9  1.11  T2    I            1     0    24  \n 3 Drug A    31  0.277 T1    II           0     0    24  \n 4 Drug A    NA 10.3   T3    III          1     1    17.6\n 5 Drug A    51  2.77  T4    III          1     1    16.4\n 6 Drug B    39  0.613 T4    I            0     1    15.6\n 7 Drug A    37  0.354 T1    II           0     0    24  \n 8 Drug A    32  1.74  T1    I            0     1    18.4\n 9 Drug A    31  0.144 T1    II           0     0    24  \n10 Drug B    34  0.205 T3    I            0     1    10.5\n# ℹ 190 more rows\n\n\nHere is an basic data dictionary for the chemo dataset:\n\n\n\nVariable\nDescription\n\n\n\n\ntrt\nTreatment group\n\n\nage\nAge in years\n\n\nmarker\nMarker level (ng/mL)\n\n\nstage\nTumor stages T1 through T4\n\n\ngrade\nTumor grade I, II, III\n\n\nresponse\nTumor response (0 = no, 1 = yes)\n\n\ndeath\nDeath (0 = no, 1 = yes)\n\n\nttdeath\nMonths to death\n\n\n\n\nShow the number of observations\n\nof the whole dataset\nper treatment group\nper treatment group and stage\n\nFor the age and marker,\n\nCalculate common statistics (range, mean, …)\nAlso visualize the variables appropriately and note anything unusual\n\nGive counts and proportions of response and death"
  },
  {
    "objectID": "06-whole-game.html#data-cleaning",
    "href": "06-whole-game.html#data-cleaning",
    "title": "5: The Whole Game",
    "section": "Data Cleaning",
    "text": "Data Cleaning\nData cleaning encompasses anything we might want to or need to change about the dataset before we do any actual analysis. This can be for cosmetic reasons, like renaming variables or recoding variables from a numeric “0 or 1” to a readable “no or yes”.\n\nPlausibility\n\nBoth age and marker contain missing values as you should have seen earlier. Substitute them with the median value of each variable. This is a simple imputation technique that’s not good enough for a clinical trial, but good enough for our purposes!\n\n\nA histogram of marker looks odd. There appears to be a strong outlier, maybe more?\n\nFor positive outliers we can “clip” them to e.g. the 95% quantile of the data.\nAre there other implausible values? What could be done about them?\n\n\n\n\nCosmetics\nOnce the data is clean in the “looks plausible” sense, we can do some cosmetic changes.\n\nRecode response and death to new variables such that 1 -&gt; “Yes” and 0 -&gt; “No”\n\nThe new variable names should be response_text and death_text while keeping the original ones!\nBoth variables should be factors sorted with Yes in the first position\nYou can use the regular ifelse() or dplyr::if_else() for this\n\nCreate a categorized age variable in 10 year groups, e.g. &lt;=10, 11–20, etc.\n\nLikely case_when() from dplyr is easiest to do this, albeit a bit verbose\nAlternative: Try cut(), which might be harder to use but more compact\n\nRename the ttdeath variable to time and the death variable to status\n\nThe verb for this is rename()!\n\n\n\n\nDon’t Forget to Save\nBy now we have modified version of our chemo dataset with a few changes we don’t want to lose, so let’s save it as a file either for sharing with colleagues or just as the starting point for subsequent analyses.\nWrite the dataset as a file to the data directory, once as an “RDS” file and once as a CSV file but with ; as the delimiter."
  },
  {
    "objectID": "06-whole-game.html#getting-ready-for-publishing",
    "href": "06-whole-game.html#getting-ready-for-publishing",
    "title": "5: The Whole Game",
    "section": "Getting Ready for Publishing",
    "text": "Getting Ready for Publishing\nNow that our data is a bit cleaner, we want to do some actual analysis.\nWe assume that the research question here is quite clear: There are two chemotherapy treatment groups in trt, and we’re interested in any differences between the two groups.\nWe will approach this both descriptively and also with a bit of statistics.\n\nDescriptives\nFor any kind of research, there’s always tables. Tons and tons of tables.\nMakign tables in R used to be a lot less comfortable than it is now, thanks to great packages like table1 and gtsummary. We’ll use gtsummary for a few common descriptive tables:\n\nlibrary(gtsummary)\n\n\nchemo |&gt;\n    select(trt, stage, grade, age) |&gt;\n    tbl_summary()\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2001\n\n\n\n\ntrt\n\n\n\n\n    Drug A\n98 (49%)\n\n\n    Drug B\n102 (51%)\n\n\nstage\n\n\n\n\n    T1\n53 (27%)\n\n\n    T2\n54 (27%)\n\n\n    T3\n43 (22%)\n\n\n    T4\n50 (25%)\n\n\ngrade\n\n\n\n\n    I\n68 (34%)\n\n\n    II\n68 (34%)\n\n\n    III\n64 (32%)\n\n\nage\n47 (38, 57)\n\n\n    Unknown\n11\n\n\n\n1 n (%); Median (Q1, Q3)\n\n\n\n\n\n\n\n\nYou’ll note that the variable names are not very nice, and we could manually set these labels in the tbl_summary function, but a neat trick is to use the labelled package actually, which make it easy to set variable labels via a form of attribute.\nUnfortunately not everything in R knows to use these labels, but gtsummary does and for now that’s good enough:\n\nlibrary(labelled)\nvar_label(chemo$trt) &lt;- \"Treatment Group\"\nvar_label(chemo$age) &lt;- \"Age\"\nvar_label(chemo$stage) &lt;- \"Stage\"\nvar_label(chemo$grade) &lt;- \"Grade\"\nvar_label(chemo$marker) &lt;- \"Marker (ng/mL)\"\nvar_label(chemo$response) &lt;- \"Tumor Response\"\n\n\nchemo |&gt;\n    select(trt, stage, grade, age) |&gt;\n    tbl_summary()\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2001\n\n\n\n\nTreatment Group\n\n\n\n\n    Drug A\n98 (49%)\n\n\n    Drug B\n102 (51%)\n\n\nStage\n\n\n\n\n    T1\n53 (27%)\n\n\n    T2\n54 (27%)\n\n\n    T3\n43 (22%)\n\n\n    T4\n50 (25%)\n\n\nGrade\n\n\n\n\n    I\n68 (34%)\n\n\n    II\n68 (34%)\n\n\n    III\n64 (32%)\n\n\nAge\n47 (38, 57)\n\n\n    Unknown\n11\n\n\n\n1 n (%); Median (Q1, Q3)\n\n\n\n\n\n\n\n\nMuch better.\nWe can also create groupings, for example by grade:\n\nchemo |&gt;\n    select(trt, stage, grade, age) |&gt;\n    tbl_summary(by = grade)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nI N = 681\nII N = 681\nIII N = 641\n\n\n\n\nTreatment Group\n\n\n\n\n\n\n\n\n    Drug A\n35 (51%)\n32 (47%)\n31 (48%)\n\n\n    Drug B\n33 (49%)\n36 (53%)\n33 (52%)\n\n\nStage\n\n\n\n\n\n\n\n\n    T1\n17 (25%)\n23 (34%)\n13 (20%)\n\n\n    T2\n18 (26%)\n17 (25%)\n19 (30%)\n\n\n    T3\n18 (26%)\n11 (16%)\n14 (22%)\n\n\n    T4\n15 (22%)\n17 (25%)\n18 (28%)\n\n\nAge\n47 (37, 56)\n49 (37, 57)\n47 (38, 58)\n\n\n    Unknown\n2\n6\n3\n\n\n\n1 n (%); Median (Q1, Q3)\n\n\n\n\n\n\n\n\nThere’s a lot more we could do with this and you can learn all about it on the package’s great documentation website at https://www.danieldsjoberg.com/gtsummary/.\n\n\n\n\n\n\nNote\n\n\n\nThe dataset chemo we used here is actually a slightly modified version of a dataset that comes with the gtsumamry package called trial! The good thing is that the documentation examples for gtsummary should be enough to get you started with chemo!\n\n\n\n\nStatistical Analysis\nDescribing the data is fine and all but what about statistics?\nWell, statistical analysis is not the focus of this course, but we can of course leverage some of the powerful tools at our disposal.\nLet’s start with ggstatsplot again:\n\nlibrary(ggstatsplot)\n\nYou can cite this package as:\n     Patil, I. (2021). Visualizations with statistical details: The 'ggstatsplot' approach.\n     Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167\n\n\nWe most likely want to look at the tumor response between the treatment groups and see whether there is any significant difference.\nThe absolute numbers don’t tell us too much yet:\n\nchemo |&gt;\n  count(response, trt)\n\n# A tibble: 4 × 3\n  response trt        n\n     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n1        0 Drug A    69\n2        0 Drug B    66\n3        1 Drug A    29\n4        1 Drug B    36\n\n\nThis function however does a lot more:\n\nggbarstats(\n  data = chemo, \n  x = response, y = trt,\n  xlab = \"Treatment Group\",\n  ylab = \"Proportion\",\n  legend.title = \"Tumor Response\"\n)\n\n\n\n\n\n\n\n\nApart from displaying percentages on a stacked barchart, it also gives us information on the result of the statistical test used to see whether the proportions are equal between treatment groups or not — and it looks like the result is not significant with p &gt; 0.05\n\nggbetweenstats(\n  data = chemo, \n  x = trt, y = marker, \n  xlab = \"Treatment\", \n  ylab = \"Marker (ng/mL)\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nNote that packages like ggstatsplot make it quite easy to do all kinds of statistical tests all the time, but just like medical diagnostic tests, it isn’t necessarily a good idea to test everything.\n\n\n\n\nAdvanced: Survival Curves\nAnother common type of plot to create is the Kaplan-Meier curve for each treatment group using the time survival time in months and the status survival indicator (0 for censoring, 1 for death).\nThe ggsurvfit package makes this very convenient:\n\n# install.packages(\"ggsurvfit\")\nlibrary(ggsurvfit)\n\nsurvfit2(Surv(time, status) ~ trt, data = chemo) |&gt;\n  ggsurvfit(linewidth = 1) +\n  add_confidence_interval() +\n  add_risktable() +\n  add_quantile(y_value = 0.6, color = \"gray50\", linewidth = 0.75) +\n  scale_ggsurvfit()"
  },
  {
    "objectID": "04-tidyverse.html",
    "href": "04-tidyverse.html",
    "title": "4: The Tidyverse",
    "section": "",
    "text": "The Tidyverse is a collection of R packages created and maintained by the same group of people, largely from the same company that also created RStudio: Posit!\nThe Tidyverse is designed to make data science easier, more efficient, and more fun.\nIt is built around the idea of tidy data, which in essence just means that data is organized in a way that makes it easy to work with. In the previous section we have already heard the two core properties of tidy data:\nAnd the tidyverse is created in part to make it easy to get your data in that shape and work with data in that shape. If R in general is a language, then we can think of “tidyverse” as a kind of dialect — it’s still R, but it has a specific context and use case and it is spoken by a community of people roughly doing similar kinds of data analysis.\nLet’s start by loading the tidyverse meta-package.\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nYou’ll see a lot of information there, and that’s nothing to worry about. What happened here is the following:\nNote that in the tidyverse, the tibble enhances the data.frame!\nTibbles are similar to data.frames, but they look nice and avoid some potentially confusing issues.\nFor now we don’t need to know more, but fur future reference you should not worry when you encounter a tibble!"
  },
  {
    "objectID": "04-tidyverse.html#tidyverse-basics-pipes-and-verbs",
    "href": "04-tidyverse.html#tidyverse-basics-pipes-and-verbs",
    "title": "4: The Tidyverse",
    "section": "Tidyverse Basics: Pipes and Verbs",
    "text": "Tidyverse Basics: Pipes and Verbs\nWe start by loading the gapminder package again for its dataset, just like we did before, but now we can glimpse it rather than str it:\n\nlibrary(gapminder)\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\nRemember how it was somewhat awkward to select specific rows and columns from the data.frame before?\nFor example, here is “country, life expectancy and population for all Asian countries in 1967” in base R syntax:\n\ngapminder[gapminder$continent == \"Asia\" & gapminder$year == 1967, \n          c(\"country\", \"lifeExp\", \"pop\")]\n\n# A tibble: 33 × 3\n   country          lifeExp       pop\n   &lt;fct&gt;              &lt;dbl&gt;     &lt;int&gt;\n 1 Afghanistan         34.0  11537966\n 2 Bahrain             59.9    202182\n 3 Bangladesh          43.5  62821884\n 4 Cambodia            45.4   6960067\n 5 China               58.4 754550000\n 6 Hong Kong, China    70     3722800\n 7 India               47.2 506000000\n 8 Indonesia           46.0 109343000\n 9 Iran                52.5  26538000\n10 Iraq                54.5   8519282\n# ℹ 23 more rows\n\n\nIn the tidyverse, or specifically dplyr syntax, we would write it like this:\n\ngapminder |&gt;\n  filter(continent == \"Asia\" & year == 1967) |&gt;\n  select(country, lifeExp, pop)\n\n# A tibble: 33 × 3\n   country          lifeExp       pop\n   &lt;fct&gt;              &lt;dbl&gt;     &lt;int&gt;\n 1 Afghanistan         34.0  11537966\n 2 Bahrain             59.9    202182\n 3 Bangladesh          43.5  62821884\n 4 Cambodia            45.4   6960067\n 5 China               58.4 754550000\n 6 Hong Kong, China    70     3722800\n 7 India               47.2 506000000\n 8 Indonesia           46.0 109343000\n 9 Iran                52.5  26538000\n10 Iraq                54.5   8519282\n# ℹ 23 more rows\n\n\nWhat happened here? Let’s dissect this one by one:\n\nWe started with the gapminder dataset, and then, via the “pipe” |&gt;,\nWe used filter() to select rows using a logical expression, and then\nWe used select() to select specific columns (without having to quote than with \"!)\n\nThis is a combination of the pipe-syntax, which passes things down to the next function, and the most common tidyverse verbs that are at the core of most data operations.\nThe pipe |&gt; works everywhere in R, and x |&gt; foo() is just a different way to write foo(x):\n\nx &lt;- 1:10\n\nlength(x)\n\n[1] 10\n\nx |&gt; length()\n\n[1] 10\n\n\nThis becomes really powerful once we chain many functions.\nConsider a made-up example:\nx |&gt;\n  do_the_thing() |&gt;\n  do_the_other_thing() |&gt;\n  twist_it() |&gt;\n  shake_it_around() |&gt;\n  do_a_little_dance()\nHere you can read the code top to bottom, and understand the sequence of events just by following the code. Consider what this would look like without the |&gt;:\ndo_a_little_dance(shake_it_around(twist_it(do_the_other_thing(do_the_thing(x)))))\nOr, with a little more indentation:\ndo_a_little_dance(\n  shake_it_around(\n    twist_it(\n      do_the_other_thing(\n        do_the_thing(x)\n      )\n    )\n  )\n)\nYou would have to read the code “inside out” to follow what’s happening here.\nAnother alternative would be to create new variables or overwrite the previous one, like so:\nx &lt;- do_the_thing(x)\nx &lt;- do_the_other_thing(x)\nx &lt;- twist_it(x)\nx &lt;- shake_it_around(x) \nx &lt;- do_a_little_dance(x)\nThe pipe syntax might take some getting used to, but usually people find it quite intuitive after a while.\nPlease keep in mind though that not everything has to be translated into a pipe-syntax, and that there are always other ways to do the same thing."
  },
  {
    "objectID": "04-tidyverse.html#common-verbs-i",
    "href": "04-tidyverse.html#common-verbs-i",
    "title": "4: The Tidyverse",
    "section": "Common Verbs (I)",
    "text": "Common Verbs (I)\nAll verbs take a data.frame (or tibble, which are almost the same thing) as their first argument, and the most important ones are:\n\nselect(): Selects variables (columns) of the dataset (without quoting them with \" \")\nfilter(): Filters the dataset to only the rows matching the condition(s) inside\narrange(): Sorts the dataset by a variable like pop, optionally in decreasing order by using desc() inside.\n\nWe start with select(), which is fairly self-explanatory and corresponds to using [ ] with column names or indices as we’ve seen before\n\ngapminder |&gt;\n  select(year, country, pop)\n\n# A tibble: 1,704 × 3\n    year country          pop\n   &lt;int&gt; &lt;fct&gt;          &lt;int&gt;\n 1  1952 Afghanistan  8425333\n 2  1957 Afghanistan  9240934\n 3  1962 Afghanistan 10267083\n 4  1967 Afghanistan 11537966\n 5  1972 Afghanistan 13079460\n 6  1977 Afghanistan 14880372\n 7  1982 Afghanistan 12881816\n 8  1987 Afghanistan 13867957\n 9  1992 Afghanistan 16317921\n10  1997 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n# If we happen to know the variable indices, this also works\ngapminder |&gt;\n  select(3, 1, 5)\n\n# A tibble: 1,704 × 3\n    year country          pop\n   &lt;int&gt; &lt;fct&gt;          &lt;int&gt;\n 1  1952 Afghanistan  8425333\n 2  1957 Afghanistan  9240934\n 3  1962 Afghanistan 10267083\n 4  1967 Afghanistan 11537966\n 5  1972 Afghanistan 13079460\n 6  1977 Afghanistan 14880372\n 7  1982 Afghanistan 12881816\n 8  1987 Afghanistan 13867957\n 9  1992 Afghanistan 16317921\n10  1997 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nIn cases where we pick out individual variables, we often want to sort by one as well:\n\ngapminder |&gt;\n  select(year, continent, country) |&gt;\n  arrange(year)\n\n# A tibble: 1,704 × 3\n    year continent country    \n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;      \n 1  1952 Asia      Afghanistan\n 2  1952 Europe    Albania    \n 3  1952 Africa    Algeria    \n 4  1952 Africa    Angola     \n 5  1952 Americas  Argentina  \n 6  1952 Oceania   Australia  \n 7  1952 Europe    Austria    \n 8  1952 Asia      Bahrain    \n 9  1952 Asia      Bangladesh \n10  1952 Europe    Belgium    \n# ℹ 1,694 more rows\n\n\nOr sorting descendingly with the desc() helper function:\n\ngapminder |&gt;\n  select(year, continent, country) |&gt;\n  arrange(desc(year))\n\n# A tibble: 1,704 × 3\n    year continent country    \n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;      \n 1  2007 Asia      Afghanistan\n 2  2007 Europe    Albania    \n 3  2007 Africa    Algeria    \n 4  2007 Africa    Angola     \n 5  2007 Americas  Argentina  \n 6  2007 Oceania   Australia  \n 7  2007 Europe    Austria    \n 8  2007 Asia      Bahrain    \n 9  2007 Asia      Bangladesh \n10  2007 Europe    Belgium    \n# ℹ 1,694 more rows\n\n\nFor a numeric variable like year we could also just sort by a negative of the variable:\n\ngapminder |&gt;\n  select(year, continent, country) |&gt;\n  arrange(-year)\n\n# A tibble: 1,704 × 3\n    year continent country    \n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;      \n 1  2007 Asia      Afghanistan\n 2  2007 Europe    Albania    \n 3  2007 Africa    Algeria    \n 4  2007 Africa    Angola     \n 5  2007 Americas  Argentina  \n 6  2007 Oceania   Australia  \n 7  2007 Europe    Austria    \n 8  2007 Asia      Bahrain    \n 9  2007 Asia      Bangladesh \n10  2007 Europe    Belgium    \n# ℹ 1,694 more rows\n\n\nBut desc() has the benefit of also working for character (sorted alphabetically) or factor variables (sorted by their levels), which makes desc() applicable in more cases.\n\ngapminder |&gt;\n  select(year, continent, country) |&gt;\n  arrange(desc(continent))\n\n# A tibble: 1,704 × 3\n    year continent country  \n   &lt;int&gt; &lt;fct&gt;     &lt;fct&gt;    \n 1  1952 Oceania   Australia\n 2  1957 Oceania   Australia\n 3  1962 Oceania   Australia\n 4  1967 Oceania   Australia\n 5  1972 Oceania   Australia\n 6  1977 Oceania   Australia\n 7  1982 Oceania   Australia\n 8  1987 Oceania   Australia\n 9  1992 Oceania   Australia\n10  1997 Oceania   Australia\n# ℹ 1,694 more rows\n\n\n\ngapminder97 &lt;- gapminder |&gt;\n  filter(year == 1997) |&gt;\n  arrange(pop)\n\nNote that in filter() you use logical expressions as we’ve seen in section 2!\nYou can combine multiple conditions by passing them as separate arguments with , which inside filter() is the same as using the logical AND with &:\n\n# Explicitly using AND & to combine year and country conditions\ngapminder |&gt;\n  filter(year == 1997 & country == \"Iceland\")\n\n# A tibble: 1 × 6\n  country continent  year lifeExp    pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;\n1 Iceland Europe     1997    79.0 271192    28061.\n\n# Identical:\ngapminder |&gt;\n  filter(\n    year &gt; 1990, \n    country == \"Iceland\"\n  )\n\n# A tibble: 4 × 6\n  country continent  year lifeExp    pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;  &lt;int&gt;     &lt;dbl&gt;\n1 Iceland Europe     1992    78.8 259012    25144.\n2 Iceland Europe     1997    79.0 271192    28061.\n3 Iceland Europe     2002    80.5 288030    31163.\n4 Iceland Europe     2007    81.8 301931    36181.\n\n\nAs a more advanced example, we can use select()-helper functions to select variables that start with a certain pattern or contain a certain word:\n\ngapminder |&gt;\n  select(starts_with(\"c\"))\n\n# A tibble: 1,704 × 2\n   country     continent\n   &lt;fct&gt;       &lt;fct&gt;    \n 1 Afghanistan Asia     \n 2 Afghanistan Asia     \n 3 Afghanistan Asia     \n 4 Afghanistan Asia     \n 5 Afghanistan Asia     \n 6 Afghanistan Asia     \n 7 Afghanistan Asia     \n 8 Afghanistan Asia     \n 9 Afghanistan Asia     \n10 Afghanistan Asia     \n# ℹ 1,694 more rows\n\ngapminder |&gt;\n  select(contains(\"gdp\"))\n\n# A tibble: 1,704 × 1\n   gdpPercap\n       &lt;dbl&gt;\n 1      779.\n 2      821.\n 3      853.\n 4      836.\n 5      740.\n 6      786.\n 7      978.\n 8      852.\n 9      649.\n10      635.\n# ℹ 1,694 more rows\n\ngapminder |&gt;\n  select(ends_with(\"p\"))\n\n# A tibble: 1,704 × 3\n   lifeExp      pop gdpPercap\n     &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1    28.8  8425333      779.\n 2    30.3  9240934      821.\n 3    32.0 10267083      853.\n 4    34.0 11537966      836.\n 5    36.1 13079460      740.\n 6    38.4 14880372      786.\n 7    39.9 12881816      978.\n 8    40.8 13867957      852.\n 9    41.7 16317921      649.\n10    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\nYour turn\n\nSelect the country and life expectancy variables for the year 1952\nSubset the dataset to only contain data recorded after 1990\nSubset the dataset to only contain data in the 1970s for Ecuador\n\n\ngapminder |&gt;\n  filter(year == 1952) |&gt;\n  select(country, lifeExp)\n\n# A tibble: 142 × 2\n   country     lifeExp\n   &lt;fct&gt;         &lt;dbl&gt;\n 1 Afghanistan    28.8\n 2 Albania        55.2\n 3 Algeria        43.1\n 4 Angola         30.0\n 5 Argentina      62.5\n 6 Australia      69.1\n 7 Austria        66.8\n 8 Bahrain        50.9\n 9 Bangladesh     37.5\n10 Belgium        68  \n# ℹ 132 more rows\n\n\n\ngapminder |&gt;\n  filter(year &gt; 1990)\n\n# A tibble: 568 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1992    41.7 16317921      649.\n 2 Afghanistan Asia       1997    41.8 22227415      635.\n 3 Afghanistan Asia       2002    42.1 25268405      727.\n 4 Afghanistan Asia       2007    43.8 31889923      975.\n 5 Albania     Europe     1992    71.6  3326498     2497.\n 6 Albania     Europe     1997    73.0  3428038     3193.\n 7 Albania     Europe     2002    75.7  3508512     4604.\n 8 Albania     Europe     2007    76.4  3600523     5937.\n 9 Algeria     Africa     1992    67.7 26298373     5023.\n10 Algeria     Africa     1997    69.2 29072015     4797.\n# ℹ 558 more rows\n\n\n\ngapminder |&gt;\n  filter(\n    year &gt;= 1970, year &lt;= 1979,\n    country == \"Ecuador\"\n  )\n\n# A tibble: 2 × 6\n  country continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Ecuador Americas   1972    58.8 6298651     5281.\n2 Ecuador Americas   1977    61.3 7278866     6680.\n\ngapminder |&gt; \n  filter(year &gt; 1969 & year &lt; 1980) |&gt; \n  filter(country == \"Ecuador\")\n\n# A tibble: 2 × 6\n  country continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Ecuador Americas   1972    58.8 6298651     5281.\n2 Ecuador Americas   1977    61.3 7278866     6680.\n\n\n\ngapminder |&gt;\n  filter(\n    between(year, 1970, 1979),\n    country == \"Ecuador\"\n  )\n\n# A tibble: 2 × 6\n  country continent  year lifeExp     pop gdpPercap\n  &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n1 Ecuador Americas   1972    58.8 6298651     5281.\n2 Ecuador Americas   1977    61.3 7278866     6680.\n\n\nHint: When you select and filter, keep in mind the order of operations!\nYou can’t filter by a variable which you have de-selected beforehand."
  },
  {
    "objectID": "04-tidyverse.html#common-verbs-ii",
    "href": "04-tidyverse.html#common-verbs-ii",
    "title": "4: The Tidyverse",
    "section": "Common Verbs (II)",
    "text": "Common Verbs (II)\nSo far we have only selected specific subsets of our data, but now we want to actually do something! For that, we have two main options:\n\nCreating a new variable\nCalculating some summary statistic like the mean or median\n\n\nmutate(): Creates a new variables, e.g. create pop_m as the variable pop divided by 1,000,000\nsummarize(): Often used together with group_by(), this summarizes the dataset by calculating something for each group declared by group_by()\ngroup_by(): Declares the dataset to be grouped by the values of variable like continent – we will see examples next!\n\n\ngapminder &lt;- gapminder |&gt;\n  mutate(pop_m = pop / 1e6)\n\ngapminder |&gt;\n  mutate(pop = pop / 1e6)\n\n# A tibble: 1,704 × 7\n   country     continent  year lifeExp   pop gdpPercap pop_m\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8.43      779.  8.43\n 2 Afghanistan Asia       1957    30.3  9.24      821.  9.24\n 3 Afghanistan Asia       1962    32.0 10.3       853. 10.3 \n 4 Afghanistan Asia       1967    34.0 11.5       836. 11.5 \n 5 Afghanistan Asia       1972    36.1 13.1       740. 13.1 \n 6 Afghanistan Asia       1977    38.4 14.9       786. 14.9 \n 7 Afghanistan Asia       1982    39.9 12.9       978. 12.9 \n 8 Afghanistan Asia       1987    40.8 13.9       852. 13.9 \n 9 Afghanistan Asia       1992    41.7 16.3       649. 16.3 \n10 Afghanistan Asia       1997    41.8 22.2       635. 22.2 \n# ℹ 1,694 more rows\n\n\n\ngapminder |&gt;\n  mutate(pop_mean = mean(pop))\n\n# A tibble: 1,704 × 8\n   country     continent  year lifeExp      pop gdpPercap pop_m  pop_mean\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  8.43 29601212.\n 2 Afghanistan Asia       1957    30.3  9240934      821.  9.24 29601212.\n 3 Afghanistan Asia       1962    32.0 10267083      853. 10.3  29601212.\n 4 Afghanistan Asia       1967    34.0 11537966      836. 11.5  29601212.\n 5 Afghanistan Asia       1972    36.1 13079460      740. 13.1  29601212.\n 6 Afghanistan Asia       1977    38.4 14880372      786. 14.9  29601212.\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12.9  29601212.\n 8 Afghanistan Asia       1987    40.8 13867957      852. 13.9  29601212.\n 9 Afghanistan Asia       1992    41.7 16317921      649. 16.3  29601212.\n10 Afghanistan Asia       1997    41.8 22227415      635. 22.2  29601212.\n# ℹ 1,694 more rows\n\ngapminder |&gt;\n  summarize(\n    pop_mean = mean(pop)\n  )\n\n# A tibble: 1 × 1\n   pop_mean\n      &lt;dbl&gt;\n1 29601212.\n\n\n\ngapminder |&gt;\n  group_by(continent)\n\n# A tibble: 1,704 × 7\n# Groups:   continent [5]\n   country     continent  year lifeExp      pop gdpPercap pop_m\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  8.43\n 2 Afghanistan Asia       1957    30.3  9240934      821.  9.24\n 3 Afghanistan Asia       1962    32.0 10267083      853. 10.3 \n 4 Afghanistan Asia       1967    34.0 11537966      836. 11.5 \n 5 Afghanistan Asia       1972    36.1 13079460      740. 13.1 \n 6 Afghanistan Asia       1977    38.4 14880372      786. 14.9 \n 7 Afghanistan Asia       1982    39.9 12881816      978. 12.9 \n 8 Afghanistan Asia       1987    40.8 13867957      852. 13.9 \n 9 Afghanistan Asia       1992    41.7 16317921      649. 16.3 \n10 Afghanistan Asia       1997    41.8 22227415      635. 22.2 \n# ℹ 1,694 more rows\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarize(mean_pop = mean(pop))\n\n# A tibble: 5 × 2\n  continent  mean_pop\n  &lt;fct&gt;         &lt;dbl&gt;\n1 Africa     9916003.\n2 Americas  24504795.\n3 Asia      77038722.\n4 Europe    17169765.\n5 Oceania    8874672.\n\n\nOr multiple things combined:\n\ngapminder |&gt;\n  filter(year &gt;= 1980) |&gt;\n  mutate(pop_m = pop / 1e6) |&gt;\n  group_by(continent) |&gt;\n  summarize(\n    mean_pop_m = mean(pop_m),\n    median_pop_m = median(pop_m),\n    min_pop_m = min(pop_m),\n    max_pop_m = max(pop_m)\n  )\n\n# A tibble: 5 × 5\n  continent mean_pop_m median_pop_m min_pop_m max_pop_m\n  &lt;fct&gt;          &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 Africa          13.6         7.10    0.0986     135. \n2 Americas        30.7         8.18    1.06       301. \n3 Asia            98.0        19.7     0.378     1319. \n4 Europe          18.7         9.03    0.234       82.4\n5 Oceania         10.8         9.65    3.21        20.4\n\n\n\nYour turn\n\ninstall the tidyverse & load with library(tidyverse)\nExplain in words what has happened in the previous code chunk.\nWhat happens if you use summarize() without group_by()?\nUse summarise() and the helpful n_distinct() to calculate the number of countries per continent\nCreate a new variable gdpPercap_m as the variable gdpPercap divided by 1 Million and rounded to 2 decimal places\n\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarize(\n    num_countries = n_distinct(country),\n    n = n()\n  )\n\n# A tibble: 5 × 3\n  continent num_countries     n\n  &lt;fct&gt;             &lt;int&gt; &lt;int&gt;\n1 Africa               52   624\n2 Americas             25   300\n3 Asia                 33   396\n4 Europe               30   360\n5 Oceania               2    24\n\ngapminder |&gt;\n  filter(continent == \"Oceania\") |&gt;\n  group_by(country) |&gt;\n  summarize(\n    n = n(),\n    num_years = n_distinct(year)\n  )\n\n# A tibble: 2 × 3\n  country         n num_years\n  &lt;fct&gt;       &lt;int&gt;     &lt;int&gt;\n1 Australia      12        12\n2 New Zealand    12        12\n\n\n\ngapminder |&gt;\n  mutate(gdpPercap_m = round(gdpPercap / 1e3, digits = 2))\n\n# A tibble: 1,704 × 8\n   country     continent  year lifeExp      pop gdpPercap pop_m gdpPercap_m\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  8.43        0.78\n 2 Afghanistan Asia       1957    30.3  9240934      821.  9.24        0.82\n 3 Afghanistan Asia       1962    32.0 10267083      853. 10.3         0.85\n 4 Afghanistan Asia       1967    34.0 11537966      836. 11.5         0.84\n 5 Afghanistan Asia       1972    36.1 13079460      740. 13.1         0.74\n 6 Afghanistan Asia       1977    38.4 14880372      786. 14.9         0.79\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12.9         0.98\n 8 Afghanistan Asia       1987    40.8 13867957      852. 13.9         0.85\n 9 Afghanistan Asia       1992    41.7 16317921      649. 16.3         0.65\n10 Afghanistan Asia       1997    41.8 22227415      635. 22.2         0.64\n# ℹ 1,694 more rows\n\ngapminder |&gt;\n  mutate(gdpPercap_m = gdpPercap / 1e6) |&gt;\n  mutate(gdpPercap_m = round(gdpPercap_m, digits = 2))\n\n# A tibble: 1,704 × 8\n   country     continent  year lifeExp      pop gdpPercap pop_m gdpPercap_m\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  8.43           0\n 2 Afghanistan Asia       1957    30.3  9240934      821.  9.24           0\n 3 Afghanistan Asia       1962    32.0 10267083      853. 10.3            0\n 4 Afghanistan Asia       1967    34.0 11537966      836. 11.5            0\n 5 Afghanistan Asia       1972    36.1 13079460      740. 13.1            0\n 6 Afghanistan Asia       1977    38.4 14880372      786. 14.9            0\n 7 Afghanistan Asia       1982    39.9 12881816      978. 12.9            0\n 8 Afghanistan Asia       1987    40.8 13867957      852. 13.9            0\n 9 Afghanistan Asia       1992    41.7 16317921      649. 16.3            0\n10 Afghanistan Asia       1997    41.8 22227415      635. 22.2            0\n# ℹ 1,694 more rows"
  },
  {
    "objectID": "04-tidyverse.html#other-useful-verbs",
    "href": "04-tidyverse.html#other-useful-verbs",
    "title": "4: The Tidyverse",
    "section": "Other Useful Verbs",
    "text": "Other Useful Verbs\n\nChanging Shapes\nA more advanced topic but often needed for data manipulation is reshaping your data using the tidyr package.\nThis might be best explained by example.\nSay we want to calculate the difference in life expectancy between 1952 and 2007 for each country and continent, but using the verbs we’ve seen so far we can’t do that with a simple mutate(). We can instead use pivot_wider() which is a function that takes a “long” dataset and pivots it into a “wide” dataset:\n\ngapminder |&gt;\n  filter(year %in% c(1952, 2007)) |&gt;\n  pivot_wider(\n    id_cols = c(country, continent), \n    names_from = year, \n    values_from = lifeExp,\n    names_prefix = \"lifeExp_\"\n  ) |&gt;\n  mutate(change_life_exp = lifeExp_2007 - lifeExp_1952)\n\n# A tibble: 142 × 5\n   country     continent lifeExp_1952 lifeExp_2007 change_life_exp\n   &lt;fct&gt;       &lt;fct&gt;            &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;\n 1 Afghanistan Asia              28.8         43.8            15.0\n 2 Albania     Europe            55.2         76.4            21.2\n 3 Algeria     Africa            43.1         72.3            29.2\n 4 Angola      Africa            30.0         42.7            12.7\n 5 Argentina   Americas          62.5         75.3            12.8\n 6 Australia   Oceania           69.1         81.2            12.1\n 7 Austria     Europe            66.8         79.8            13.0\n 8 Bahrain     Asia              50.9         75.6            24.7\n 9 Bangladesh  Asia              37.5         64.1            26.6\n10 Belgium     Europe            68           79.4            11.4\n# ℹ 132 more rows\n\n\n\n\nCombining Things\nSometimes it’s useful to combined datasets by rows or columns:\nbind_rows() is for rows, similar to base R’s rbind() but has some advantages\n\ngapminder52 &lt;- gapminder |&gt;\n  filter(year == 1952)\n\ngapminder07 &lt;- gapminder |&gt;\n  filter(year == 2007)\n\nbind_rows(gapminder52, gapminder07)\n\n# A tibble: 284 × 7\n   country     continent  year lifeExp      pop gdpPercap  pop_m\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;  &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.  8.43 \n 2 Albania     Europe     1952    55.2  1282697     1601.  1.28 \n 3 Algeria     Africa     1952    43.1  9279525     2449.  9.28 \n 4 Angola      Africa     1952    30.0  4232095     3521.  4.23 \n 5 Argentina   Americas   1952    62.5 17876956     5911. 17.9  \n 6 Australia   Oceania    1952    69.1  8691212    10040.  8.69 \n 7 Austria     Europe     1952    66.8  6927772     6137.  6.93 \n 8 Bahrain     Asia       1952    50.9   120447     9867.  0.120\n 9 Bangladesh  Asia       1952    37.5 46886859      684. 46.9  \n10 Belgium     Europe     1952    68    8730405     8343.  8.73 \n# ℹ 274 more rows\n\n\nbind_cols() combined datasets by columns, similar to base R’s cbind().\nFor example, here is a way to create to year-specific variables similar to the pivot_wider() example above\n\ngapminder52 &lt;- gapminder |&gt;\n  filter(year == 1952) |&gt;\n  rename(lifeExp_1952 = lifeExp)\n\ngapminder07 &lt;- gapminder |&gt;\n  filter(year == 2007) |&gt;\n  select(lifeExp) |&gt;\n  rename(lifeExp_2007 = lifeExp)\n\nbind_cols(gapminder52, gapminder07) |&gt;\n  select(starts_with(\"lifeExp\"))\n\n# A tibble: 142 × 2\n   lifeExp_1952 lifeExp_2007\n          &lt;dbl&gt;        &lt;dbl&gt;\n 1         28.8         43.8\n 2         55.2         76.4\n 3         43.1         72.3\n 4         30.0         42.7\n 5         62.5         75.3\n 6         69.1         81.2\n 7         66.8         79.8\n 8         50.9         75.6\n 9         37.5         64.1\n10         68           79.4\n# ℹ 132 more rows"
  },
  {
    "objectID": "02-fundamentals.html",
    "href": "02-fundamentals.html",
    "title": "2: R Fundamentals",
    "section": "",
    "text": "This is a Quarto document. It contains regular text, code, and output when viewed in RStudio. It can also be converted into an HTML (or PDF) document, where code and output are shown together as well.\nThis text is formatted using Markdown, a lightweight syntax that uses asterisks (*), underscores (_), hyphens (-), and parentheses / brackets (() and []) to format text. We can also embed images:\n\n\n\nrstudio-overview\n\n\nWe can also write R code in a code block and execute it using either Ctrl + R like in a regular script or using the green button on the top right of the cell:\n\n# Hello\n10 * 5.3\n\n[1] 53\n\n-5 + 10\n\n[1] 5\n\n9^2\n\n[1] 81\n\n2 + 5 / 4\n\n[1] 3.25\n\n(2 + 5) / 4\n\n[1] 1.75\n\n\nThroughout the workshop, we will use this format to interweave text and explanations with code examples. You can modify the code in the blocks and rerun them to see the results, and later we will provide partial code examples where your task will be to complete them to solve a given task.\nBefore we try to do any data analysis, we first need to familiarize ourselves with R to know our way around!\nIn the example script 01-hello.R we have already seen that R can be used like a big calculator, and that’s already pretty useful. For now, we’ll build on that a little."
  },
  {
    "objectID": "02-fundamentals.html#hello-there",
    "href": "02-fundamentals.html#hello-there",
    "title": "2: R Fundamentals",
    "section": "",
    "text": "This is a Quarto document. It contains regular text, code, and output when viewed in RStudio. It can also be converted into an HTML (or PDF) document, where code and output are shown together as well.\nThis text is formatted using Markdown, a lightweight syntax that uses asterisks (*), underscores (_), hyphens (-), and parentheses / brackets (() and []) to format text. We can also embed images:\n\n\n\nrstudio-overview\n\n\nWe can also write R code in a code block and execute it using either Ctrl + R like in a regular script or using the green button on the top right of the cell:\n\n# Hello\n10 * 5.3\n\n[1] 53\n\n-5 + 10\n\n[1] 5\n\n9^2\n\n[1] 81\n\n2 + 5 / 4\n\n[1] 3.25\n\n(2 + 5) / 4\n\n[1] 1.75\n\n\nThroughout the workshop, we will use this format to interweave text and explanations with code examples. You can modify the code in the blocks and rerun them to see the results, and later we will provide partial code examples where your task will be to complete them to solve a given task.\nBefore we try to do any data analysis, we first need to familiarize ourselves with R to know our way around!\nIn the example script 01-hello.R we have already seen that R can be used like a big calculator, and that’s already pretty useful. For now, we’ll build on that a little."
  },
  {
    "objectID": "02-fundamentals.html#variables-and-vectors",
    "href": "02-fundamentals.html#variables-and-vectors",
    "title": "2: R Fundamentals",
    "section": "Variables and Vectors",
    "text": "Variables and Vectors\nWe have seen how to assign values to a variable, such as age &lt;- 30. This allows us to re-use data and give it a meaningful(!) name in our work. It becomes more useful when we store not just individual number (scalars), but vectors of data.\nFor example, say we have a small group of patients want to store their basic data, starting with their age:\n\nage &lt;- c(30, 33, 31, 29, 40)\n\nage\n\n[1] 30 33 31 29 40\n\n\nNow age is a vector, and in R this is the most common type of data structure we deal with. Note that in R, even single numbers like 5 are treated like vectors (of length 1)!\nWe can use vectors almost exactly like single numbers for basic math:\n\nage + 5\n\n[1] 35 38 36 34 45\n\nage - 10\n\n[1] 20 23 21 19 30\n\nage * 4\n\n[1] 120 132 124 116 160\n\nage / 5\n\n[1] 6.0 6.6 6.2 5.8 8.0\n\nage^2\n\n[1]  900 1089  961  841 1600\n\n\nWhat R here is doing is a form of vectorization, by using each element of the vector for the calculation and returning another vector.\nWe can also conveniently create sequences of numbers using the colon notation :\n\n# 1 through 10\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n# -5 through 5\n-5:5\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n\nIf we add vectors of the same length, R will try to add each element separately:\n\nage\n\n[1] 30 33 31 29 40\n\n# Same length: ok\nage + 1:5\n\n[1] 31 35 34 33 45\n\n# not same length: not ok\nage + 1:7\n\nWarning in age + 1:7: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 31 35 34 33 45 36 40\n\n\nBut what happens here?\n\nage + 1:10\n\n [1] 31 35 34 33 45 36 40 39 38 50\n\n\nThis is called recycling and can be great or introduce unexpected behavior if it happens by accident!\nA simpler example:\n\nx &lt;- c(5, 5, 5, 5, 5, 5)\nx + c(-1, 1)\n\n[1] 4 6 4 6 4 6\n\n\n\nYour turn: Creating vectors & variables\n\nCreate a vector containing the letters “A”, “B”, “C”, “D”.\nCreate a vector containing the decimal numbers 1.2, 4.7, 9.4.\nCreate a vector containing the integers from 10 to 1 in descending order and without writing out the elements.\nCreate a vector containing a sequence from 10 to 40 in steps of 10, without writing out the elements. Using Google, can you find a function to achieve the same result?\nAssign the vectors (1.2, 3.4) and (3.6, 5.7) to the variables x and y. Combine these into a single vector z = (1.2, 3.4, 3.6, 5.7) without writing out the individual elements / numbers.\n\n\n# 1. vector ABCD\nc(\"A\", \"B\", \"C\", \"D\")\n\n[1] \"A\" \"B\" \"C\" \"D\"\n\n# 2.\nc(1.2, 4.7, 9.4)\n\n[1] 1.2 4.7 9.4\n\n# 3.\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n# 4.\n1:4 * 10\n\n[1] 10 20 30 40\n\nseq(from = 10, to = 40, by = 10)\n\n[1] 10 20 30 40\n\n# 5.\nx &lt;- c(1.2, 3.4)\ny &lt;- c(3.6, 5.7)\nz &lt;- c(x, y) \n# Identical to\nz &lt;- c(1.2, 3.4, 3.6, 5.7)\n\n\n\nYour turn: Working with variables\nLet’s assume more patient data:\n\nheight_cm &lt;- c(184, 174, 171, 179, 180)\nweight_kg &lt;- c(75, 64, 70, 85, 78)\n\n\nUsing the variables above, calculate the BMI for each patient.\nStore the result in a variable called bmi. Keep in mind you can use parentheses to group calculations like in a calculator, e.g. (x + 4) * y\n\n\nheight_cm &lt;- c(184, 174, 171, 179, 180)\nweight_kg &lt;- c(75, 64, 70, 85, 78)\n\nweight_kg/height_cm^2\n\n[1] 0.002215265 0.002113886 0.002393899 0.002652851 0.002407407"
  },
  {
    "objectID": "02-fundamentals.html#functions",
    "href": "02-fundamentals.html#functions",
    "title": "2: R Fundamentals",
    "section": "Functions",
    "text": "Functions\nOn vectors, we can use additional functions common in statistics and data analysis:\n\nmean(age)\n\n[1] 32.6\n\nmedian(age)\n\n[1] 31\n\n\n\n# variance\nvar(height_cm)\n\n[1] 26.3\n\n# standard deviation (root of variance)\nsd(height_cm)\n\n[1] 5.128353\n\n# inter-quartile range\nIQR(height_cm)\n\n[1] 6\n\n# minimum and maximum\nrange(height_cm)\n\n[1] 171 184\n\n\n\n# Number of elements (length) of the vector\nlength(height_cm)\n\n[1] 5\n\n# Sum of all elements\nsum(height_cm)\n\n[1] 888\n\n# Handy \"common statistics\" summary\nsummary(height_cm)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  171.0   174.0   179.0   177.6   180.0   184.0 \n\n\nFunctions can take arguments which specify further options, always separated by a comma ,. Example: To calculate the quartiles of a vector without summary(), we take the function quantile() to calculate the 25%, 50%, and 75% quartiles:\n\nquantile(height_cm, probs = c(0.25, 0.5, 0.75))\n\n25% 50% 75% \n174 179 180 \n\n\nNote that function arguments are always declared with the = character! We will learn more about function arguments later.\n\nYour turn\nWithout using the function mean or summary, calculate the mean height (height_cm) using the other available functions.\nHint: The mean is defined as the sum of the values divided by the number of entries.\n\nsum(height_cm)/length(height_cm)\n\n[1] 177.6"
  },
  {
    "objectID": "02-fundamentals.html#vector-types",
    "href": "02-fundamentals.html#vector-types",
    "title": "2: R Fundamentals",
    "section": "Vector Types",
    "text": "Vector Types\nSo far we have seen numeric values only, but there are other useful types we will need down the road, and maybe a detail that might be good to know.\nIn R, there are these basic types:\n\nNumeric for numbers:\n\n10, -3.2, and the value of pi\n\nCharacter for text:\n\n\"hello\", \"a\" and \"\" (an empty string)\n\nLogical (also “boolean”):\n\nEither TRUE or FALSE\n\n\nWhen we create a vector, it can only be of one type!\n\n# Numeric vector\nc(1, 2, 3)\n\n[1] 1 2 3\n\n# Character vector\nc(\"1\", \"a\", \"v\")\n\n[1] \"1\" \"a\" \"v\"\n\n# Also become a character vectors!\nc(1, 2, \"3\")\n\n[1] \"1\" \"2\" \"3\"\n\nc(1, TRUE, FALSE, \"a\")\n\n[1] \"1\"     \"TRUE\"  \"FALSE\" \"a\"    \n\n\n“Numeric” is technically a class further separated into whole numbers (integers) and decimal numbers. The latter are referred to as “floating point numbers” and the type is called “double” for boring history-of-computing reasons. Usually a numeric vector in R is a double, unless explicitly denoted an integer. You can check the difference with the function typeof(), e.g. typeof(3)\nThe important bit is that they have upper and lower limits because computers can’t store numbers with arbitrary precision:\n\n10^3\n\n[1] 1000\n\n10^10\n\n[1] 1e+10\n\n10^100\n\n[1] 1e+100\n\n10^1000\n\n[1] Inf\n\n# Too close to zero\n10^-1000\n\n[1] 0\n\n\nThe e here is for “exponent” and 1e5 is identical to 1 * 10^5, and 2e-3 is 2 * 10^-3 or 0.002.\nIntegers are sometimes used explicitly, and we write them like so: 1L (the “L” has weird historic reasons). It can be useful to use integers explicitly, or to be aware of your data being in integer format rather than double.\n\ntypeof(3)\n\n[1] \"double\"\n\ntypeof(3L)\n\n[1] \"integer\"\n\n\nCharacters are useful for text and categorical information, for example to denote regions of origin in a dataset:\n\ncontinents &lt;- c(\"Europe\", \"North America\", \"East Asia\")\n\nFor logicals it’s important to note that TRUE and FALSE are reserved words, so you can’t use them as variable names.\n\n\n\n\n\n\nNote\n\n\n\nSome \"character\"-related things to keep on the “I know where to look it up” pile:\n\nc(\"apples\", \"oranges\") is a character vector of length 2. You might encounter the notation character(2) to refer to this type and length\nA character vector has a length just like any other vector retrievable with length(x)\nIf you want to know the number of characters in a character vector, use nchar(x)\nnchar(c(\"apples\", \"oranges\")) gives you the number of characters for each string!\n\n\n\n\nChanging Types\nIn many cases we can change the type of a vector from one to another, but only if it is meaningful to do so.\nFor example, we can use as.character() to turn any numeric vector into a character vector and we will be able to convert it back with as.numeric(), but if we start with a character vector like c(\"apples\", \"bananas\"), there’s no meaningful way to convert it to a numeric vector!\n\nas.character(1:5)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\nas.numeric(as.character(1:5))\n\n[1] 1 2 3 4 5\n\nas.numeric(c(\"apples\", \"bananas\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] NA NA\n\n\n\n\nYour Turn\n\nCreate vectors of the types integer, double, character and logical\nExperiment with the functions as.numeric, as.integer, as.double, as.character, as.logical"
  },
  {
    "objectID": "02-fundamentals.html#missing-data",
    "href": "02-fundamentals.html#missing-data",
    "title": "2: R Fundamentals",
    "section": "Missing data",
    "text": "Missing data\nAt some point in your analysis, you will always encounter missing data. Whether it’s measurement error or a partial survey response, there’s no way to avoid it.\nIn R, missing values are denoted NA, for “Not Available”. It’s important to note that there is absolute no information, so we can not do anything with missing values:\n\n# vector with missing value\nage &lt;- c(30, 32, 38, 27, NA, 27, 29, NA, 30, 31)\n\nmean(age)\n\n[1] NA\n\nsum(age)\n\n[1] NA\n\n\nThe missing value(s) could be anything, so R is cautious and refuses to give you any sort of answer!\nWhat do we do with that?"
  },
  {
    "objectID": "02-fundamentals.html#the-help",
    "href": "02-fundamentals.html#the-help",
    "title": "2: R Fundamentals",
    "section": "The Help",
    "text": "The Help\nWe really want the mean of the age here, but we don’t want to exclude an entire patient from our dataset.\nWe can check R’s built-in help system by adding a ? in front of any function name (without parentheses). Try it out using the mean function!:\n\n?mean\n\nA help page always has the same format:\n\nThe name of the function or help page topic\nDescription tells you what it does\nUsage shows you what other arguments the function has, followed by…\nArguments explaining each one in more detail\nValue tells you what the function returns, like mean() returning a scalar, but range() returning a vector with 2 values\nExamples show you concrete code examples that you can usually copy and paste into the console to see the function in action! This where we hope the developer has taken the time to provide good examples :)\n\n\nYour turn\n\nCalculate the mean of the age variable above with the missing value, using the mean function (Remember the name of the relevant argument - it will come up often!)\nWhat else can mean do that might be useful sometimes?\nAlso calculate the median and variance of age\n\nBonus:\n\nLook at the help page of table(). It looks a little different in the “Usage” part"
  },
  {
    "objectID": "02-fundamentals.html#more-vector-work",
    "href": "02-fundamentals.html#more-vector-work",
    "title": "2: R Fundamentals",
    "section": "More Vector-Work",
    "text": "More Vector-Work\nNow we can already do many things with vectors, but there is one important thing missing:\nWe can’t access individual elements or ranges yet. In R, we do that using square brackets with an index number: x[1] gives us the first element of x.\nSome examples:\n\nx &lt;- 11:20\n\nx[1]\n\n[1] 11\n\nx[5:7]\n\n[1] 15 16 17\n\nx[c(1, 2, 6)]\n\n[1] 11 12 16\n\n\nThis is called indexing a vector and it’s one of the most common operations!\nWe will practice this later, but before we do…\n\nA Little Logic Crash Course\nWe spoke of logical values before, and it’s time to get to know them a little better!\nOne of the most common applications is in comparisons, i.e., is x greater, equal, or less than y? In R, we can do these comparisons using logical operators:\n\nx == Equals (two = signs without space in between)\nx != Not Equal (Exclamation point and = without space in between)\nx &gt; y and x &lt; y Greater and Less than (left and right angle brackets)\nx &gt;= y and x &lt;= y Greater or equal and Less than or equal (angle brackets with =)\nx %in% y is x in y?\n\nAny statement such as x == y or a &lt; b results in a logical value: TRUE or FALSE.\nfor example for some fictitious weight data:\n\nweight_kg &lt;- c(75, 64, 71, 45, 85, 78, 101, 94, 62, 70, 52)\n\nweight_kg &gt; 60\n\n [1]  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE\n\nweight_kg == 101\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\nweight_kg &lt; 75\n\n [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n85 %in% weight_kg\n\n[1] TRUE\n\n\nThese can be combined using\n\n& AND: a & b is TRUE if and only if both a and b are TRUE and otherwise FALSE\n| OR: a | b is TRUE if either a or b is TRUE and FALSE if both are FALSE\n\nOne of the most common things to do in data analysis is to filter data based on logical comparisons, such as “patients with blood pressure over a certain threshold” or “patients who are male and older than 65”.\n\nweight_kg &lt; 60 | weight_kg &gt; 90\n\n [1] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\n\nIt can be useful to turn the TRUE and FALSEs into the index positions of the vector:\n\nweight_kg == 101\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n\nwhich(weight_kg == 101)\n\n[1] 7\n\n\nThis tells us the 7th element is the one with the value 101.\nWe can also use functions for help, like finding out which position in the vector is the smallest or largest\n\nwhich(weight_kg == min(weight_kg))\n\n[1] 4\n\nwhich(weight_kg == max(weight_kg))\n\n[1] 7\n\n\nThis is so useful that R has functions for that, see ?which.min\n\n\nVector Indexing\nNow we have all the tools we need to slice and dice our vectors! Because with the x[&lt;index&gt;] notation for vector subsetting (indexing), we can also use logical values, which is very powerful!\nif we use a logical vector for indexing, R will give us all the elements of the vector for which the index wasTRUE and omit those that were FALSE:\n\nweight_kg &lt;- c(75, 64, 71, 45, 85, 78, 101, 94, 62, 70, 52)\n\nweight_kg[weight_kg &lt; 60]\n\n[1] 45 52\n\nweight_kg[weight_kg &gt; 85]\n\n[1] 101  94\n\nweight_kg[weight_kg &lt; 60 | weight_kg &gt; 80]\n\n[1]  45  85 101  94  52\n\n\nNote that using some of the functions from earlier we can already do some simple analysis by just counting, which is easy for logical values because sum() treats TRUE like a 1 and FALSE like a 0\n\nlength(weight_kg)\n\n[1] 11\n\nsum(weight_kg &lt; 60)\n\n[1] 2\n\nsum(weight_kg &lt; 10)\n\n[1] 0\n\n\nWe can also change parts of a vector like this, like changing the 4th element to the value of 20:\n\nx &lt;- 1:5\nx\n\n[1] 1 2 3 4 5\n\nx[4] &lt;- 20\nx\n\n[1]  1  2  3 20  5\n\n\n\n\nYour turn\nUsing the weight_kg variable above, subset it to find out…\n\nHow many values are smaller than the mean weight?\nHow many are between 30 and 70?\nHow many are between the 20% and 75% quantile?\nIf we define outliers as those outside the 10% and 90% quantile, do we find any outliers?\n\nAnother useful indexing function is is.na(), which tells you whether a value is NA or not.\nRemember the age variable before?\n\nage &lt;- c(30, 32, 38, 27, NA, 27, 29, NA, 30, 31)\n\n\nFind the index positions of the NA values\nReplace the NA values with the mean age when missing values are ignored"
  },
  {
    "objectID": "02-fundamentals.html#appendix-useful-functions-for-vectors",
    "href": "02-fundamentals.html#appendix-useful-functions-for-vectors",
    "title": "2: R Fundamentals",
    "section": "Appendix: Useful Functions for Vectors",
    "text": "Appendix: Useful Functions for Vectors\nLike with every language, there is always a certain set of vocabulary you’ll just have to learn and remember. The next best thing is of course knowing where to look them up.\nIn that regard, here is a list of common function which might come in handy at some point!\nRemember to use the help with ?function to learn more (or use Google, or ChatGPT, or whatever works!)\n\nc() combines values into vectors. Can also combine multiple vectors into one!\nround() to round values to some number of digits.\nlength() for the number of elements\nunique() removes any duplicates\n\nanyDuplicated tells you if there are duplicates in the first place\n\n\n\nTypes\n\nas.character(), as.numeric(), as.integer() and as.logical() convert types\nis.character(), is.numeric(), is.integer() and is.logical() check types\nclass() and typeof() tell you what the vector is (the details are technical and not too important for now)"
  },
  {
    "objectID": "02-fundamentals.html#math-operators",
    "href": "02-fundamentals.html#math-operators",
    "title": "2: R Fundamentals",
    "section": "Math Operators",
    "text": "Math Operators\n\n+, - for addition and subtraction\n*, / for multiplication and division\n2^6, log(64, base = 2) for exponentiation and logarithms\n%% modulo, i.e. division with rest\n\n\nDescribing Data\n\nsummary() gives you a list of statistics for a vector (and also works on other types of objects we’ll see later!)\ntable() gives you a frequency table, or a simple 2x2 table if you supply two vectors\nquantile(..., probs = ...) for quantiles at probabilities given as probs\nmean(), median() give you what you’d expect\nvar() for variance and sd() for the standard deviation\nmin() and max() for minimum and maximum of a vector, range() for both\nsum() for the sum of a vector, see also it’s lesser known sibling, diff()\ncumsum() the cumulative sum, so a vector of the same length but each element is the sum of all previous elements\n\n\n\nSequences\n\nseq() creates sequences from whicher start, end, and step size you provide\na:b also creates sequences, but always from a to b in steps of 1\nseq_len() creates a sequence from 1 to whatever you provide - a shortcut for 1:n\nrep() repeat elements to form a vector, e.g. rep(c(1, 0), times = 3)\n\n\n\nRandom Numbers / Probability Distributions\nR is first and foremost a statistical language, and as such it has great facilities for working with random number sand probability distributions. These functions come in 4 versions with different first letters for\n\nr to draw random numbers\nd for values from a probability distribution\np for probabilities\nq for quantiles of a distribution\n\nfollowed by the type of distribution, e.g.\n\nunif for the uniform distribution\nnorm for the normal distribution\nbinom for the Binomial distribution\npois for the Poisson distribution\n\nso for the normal distribition, we have the functions rnorm(), dnorm(), pnorm() and qnorm().\nSome examples:\n\nrnorm(10, mean = 100, sd = 15) 10 normally distributed numbers with mean 15 and SD of 5\ndbinom(4, size = 10, prob = 0.5) probability of 4 successes after 10 trials with a probability of 0.5 for a Binomial event (like coin flips)\npbirthday(20, classes = 365, coincident = 2) probability of two people sharing the same birthday in a group of 20\n\nSee also ?Distributions"
  },
  {
    "objectID": "README.html",
    "href": "README.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Introduction to data management and data analysis with R and RStudio."
  },
  {
    "objectID": "README.html#outline",
    "href": "README.html#outline",
    "title": "Introduction to R",
    "section": "Outline",
    "text": "Outline\nThe course is grouped into (potentially overlapping) sections which do not necessarily need to correspond to workshop days.\nThe sections are:\n\n1. Getting started\n\nSetting up R and RStudio and getting familiar with RStudio as an environment\n\nBasic R syntax and common language features such as the included help system\n\nEssential data types and data structures\n\nFamiliarization with example datasets used throughout the course\n\nUsing Quarto as the environment for code examples and exercises\n\n\n\n2. Exploratory data analysis\n\nCreating and manipulating tabular data with the tidyverse\n\nPreparing for typical data cleaning tasks\n\nData visualization basics using ggplot2\n\nDescriptive statistics to understand one’s data\nAssess data integrity\n\nPaving the way for publication-ready tables and visualizations using extension packages\n\n\n\n3. Statistical analysis\n\nBasic hypothesis testing for common research questions"
  },
  {
    "objectID": "README.html#prerequisites",
    "href": "README.html#prerequisites",
    "title": "Introduction to R",
    "section": "Prerequisites",
    "text": "Prerequisites\nIdeally R and RStudio are already installed at the start of the course. See these instructions for example.\nIf a local setup is not feasible, consider using an online service such as Posit Cloud (see below)."
  },
  {
    "objectID": "README.html#how-to-use-this-repository",
    "href": "README.html#how-to-use-this-repository",
    "title": "Introduction to R",
    "section": "How to use this repository",
    "text": "How to use this repository\nDepending on your setup, you can either work with these materials locally on your own computer or in the browser on a cloud service, Posit Cloud.\nInstalling the required packages is part of the course, but if you want to be safe and install them in advance (e.g. due to technical issues like an unstable internet connection) follow these instructions depending on your preferences / needs and afterwards refer to scripts/install-packages.R and run the commands to install the R packages.\n\nLocally with R / RStudio installed\n\n\nClick to show instructions\n\n\nOn the GitHub page, click the green “Code” button and choose “Download ZIP”\nExtract the downloaded ZIP file\nDouble-click course_introduction_to_r.Rproj\n\n\n\n\n\nUsing posit.cloud\n\n\nClick to show instructions\n\nLog in on https://posit.cloud using whichever method you prefer (it’s free!)\nChoose “New Project”\n\nChoose “New project from Git repository”\n\nFor the URL, enter https://github.com/bips-hb/course_introduction_to_r.git"
  },
  {
    "objectID": "README.html#additional-materials",
    "href": "README.html#additional-materials",
    "title": "Introduction to R",
    "section": "Additional materials",
    "text": "Additional materials\n\nIntroductory courses\nMaterials here are in part inspired by the great work other people have already done and kindly shared with the community!\n\nR Crash Course (based on a Software Carpentry course)\nThe R Workshop by Rebecca L. Barter\n\n\n\nBooks\n\nR for Data Science by Hadley Wickham et al.\nAdvanced R by Hadley Wickham\nWhat They Forgot to Teach You About R by Jennifer Bryan et al.\nThe R Graphics Cookbook by Winston Chang."
  },
  {
    "objectID": "03-tabular-data.html",
    "href": "03-tabular-data.html",
    "title": "3: Tabular Data",
    "section": "",
    "text": "So far we have used individual vectors as data, but of course it is not particularly convenient to work with real data like that. Whether your data originally is stored in an Excel file or some sort of database system, it is usually stored in a tabular format, ideally with two key properties:\nIn the real world, data tends to come in all shapes and sizes, but for the purposes of analysis this is the shape to strive for.\nJust like we made up some patient data to store as vectors, we can use the same approach to create tabular data, using the data.frame() function. Each argument of this function takes a vector just like we used before, so in a sense the data.frame is just a way to organize vectors that all must have the same length!\nexample_df &lt;- data.frame(\n  id = 1:5,\n  age = c(35, 32, 26, 40, 34),\n  weight_kg = c(75, 64, 71, 45, 85)\n)\n\nexample_df\n\n  id age weight_kg\n1  1  35        75\n2  2  32        64\n3  3  26        71\n4  4  40        45\n5  5  34        85"
  },
  {
    "objectID": "03-tabular-data.html#working-with-tabular-data",
    "href": "03-tabular-data.html#working-with-tabular-data",
    "title": "3: Tabular Data",
    "section": "Working with Tabular Data",
    "text": "Working with Tabular Data\nWe manipulated vectors by indexing them with [ ], things are more complicated with data.frames but fundamentally the idea is the same!\nWe can access individual columns of the data.frame like the vectors they are using either $ or double brackets for indexing [[ ]] where the index can be the integer index or the name of the variable, so these are all identical and result in a vector:\n\nexample_df$age\n\n[1] 35 32 26 40 34\n\nexample_df[[2]]\n\n[1] 35 32 26 40 34\n\nexample_df[[\"age\"]]\n\n[1] 35 32 26 40 34\n\nexample_df$id\n\n[1] 1 2 3 4 5\n\nexample_df$weight_kg\n\n[1] 75 64 71 45 85\n\n\nSince this gives us a vector, we can do the usual vector things:\n\n# First 5 age values\nexample_df$age[1:5]\n\n[1] 35 32 26 40 34\n\n# All age values under 30\nexample_df$age[example_df$age &lt; 30]\n\n[1] 26\n\n# 2nd column, 3rd element\nexample_df[[2]][3]\n\n[1] 26\n\n\nThis becomes inconvenient really quickly though, which is why there are better ways we’ll see soon.\nNote that this way we can only ever get one vector, so this does not work as we might expect:\n\nexample_df[[c(1, 2)]]\nexample_df[[c(\"id\", \"age\")]]\n\nWe can however use single brackets to access one or more columns, rows, or both, and it get’s a little more complex:\n\n# First column, result is a data.frame\nexample_df[1]\n\n  id\n1  1\n2  2\n3  3\n4  4\n5  5\n\nexample_df[\"id\"]\n\n  id\n1  1\n2  2\n3  3\n4  4\n5  5\n\n# 3rd row\nexample_df[3, ]\n\n  id age weight_kg\n3  3  26        71\n\n# First column, 5th row\nexample_df[5, 1]\n\n[1] 5\n\nexample_df[5, \"id\"]\n\n[1] 5\n\n\nWhen we use single brackets, the result is still a data.frame unless in the last case where the result is a scalar. This can become somewhat tricky, but if you insist on the result being a data.frame you can add drop = FALSE:\n\nexample_df[5, 1]\n\n[1] 5\n\nexample_df[5, 1, drop = FALSE]\n\n  id\n5  5\n\n\nThis is a “good to know and easy to forget” bit of information. Soon we will introduce mechanisms to make working with tabular data a bit more intuitive, but since you will most likely encounter this type of code in the wild, we’ll practice it a little soon.\n\nexample_df[example_df$age &gt;= 30, ]\n\n  id age weight_kg\n1  1  35        75\n2  2  32        64\n4  4  40        45\n5  5  34        85"
  },
  {
    "objectID": "03-tabular-data.html#external-data",
    "href": "03-tabular-data.html#external-data",
    "title": "3: Tabular Data",
    "section": "External Data",
    "text": "External Data\n\nBuilt-in\nR comes with some built-in datasets that are “just there”:\n\nsleep\nmtcars\niris\n\nThey are built-in in the sense that they are part of the R installation - you can not accidentally delete them and you don’t need to do anything special to access them, which makes them the standard case for tutorials and examples — and of course also a little boring!\nWe can also install packages that provide additional data, and many packages that provide some sort of statistical or visualization functionality often include toy datasets to illustrate their use.\nWe’ll see examples of that later as well!\n\n\nReading and Writing Data from/to Files\nA usual part of the workflow is to import data, clean it up, modify it in some way, and then storing it as a file for later use or to share it with collaborators.\nThere are many formats we could use, and they vary in how simple they are to use within R, how easy it is to read them with other software, and how certain you want to be that people are going to be able to read the data in 30 years.\nFor simplicity we’ll focus on two kinds of formats: R’s built-in format RDS, and plain-text delimited formats like CSV and TSV.\n\nRDS\nRDS has the benefit of being able to losslessly store any kind of R objects, which means that whatever you store as a file on your computer you’ll most likely be able to just read into R again and use it as if nothing happened.\nThis is why RDS is the most popular for “within R” workflow where you want to store intermediate results for example, or cleaned datasets you want to use later for analysis in a different R project.\nWe can store and restore data to RDS like this, using the example_df and the data directory in this project:\n\ngetwd()\n\n[1] \"/Users/Lukas/repos/github/bips-hb/course_introduction_to_r\"\n\nsaveRDS(example_df, file = \"data/example_df.rds\")\n\n\nexample_rds &lt;- readRDS(file = \"data/example_df.rds\")\n\nWe can check if the two are identical:\n\nidentical(example_df, example_rds)\n\n[1] TRUE\n\n\n\nCreate a data.frame called test_dfwith 3 variables\nSave to data/test.rds\nRead it back and name the variable read_test\n\n\ntest_df &lt;- data.frame(\n  letter = c(\"A\", \"B\", \"C\", \"hello\"),\n  height_cm = c(123, 346, 123, 7457),\n  logical = c(TRUE, FALSE, TRUE, TRUE)\n)\ntest_df\n\n  letter height_cm logical\n1      A       123    TRUE\n2      B       346   FALSE\n3      C       123    TRUE\n4  hello      7457    TRUE\n\nsaveRDS(test_df, file = \"data/test.rds\")\nread_test &lt;- readRDS(file = \"data/test.rds\")\n\nidentical(test_df, read_test)\n\n[1] TRUE\n\n\n\n\n\nCSV\nComma separated values (CSV) are maybe the most common way to share data that’s not large enough to require database or strong compression. If you want to share data in a way that others can import it into Excel without a big headache, this is probably the way to go!\nAlso if you want to make sure that your great-great-great-grandchildren are still able to read your data without any special software.\nIt’s the lowest common denominator in many ways, and it can be very annoying to deal with.\nIn the simplest case we can read and write CSVs with read.csv()\n\nwrite.csv(example_df, file = \"data/example_csv123.csv\", \n          row.names = FALSE)\n\n\nexample_csv &lt;- read.csv(file = \"data/example_csv123.csv\")\n\nNote that ?read.csv and ?write.csv show a few option that will be useful at some point, like sep. By default, we write and read comma-delimited files, but we could also do sep = \";\" to use ; as a separating character!\nWhen you try to read data with Excel for example, then using ; might make things easier.\nWhen it comes to reading external data, tons of things can go wrong and for now, we just assume that it went okay.\nFor future reference though:\n\nWhen in doubt, google around for how to best read the given data into R\nEnsure to glance at the relevant documentation, e.g. for ?read.csv, if you run into errors or unexpected behavior\nOnce you’re used to installing packages, the readr package might be of interest here\nRefer to this chapter in R4DS for more information and examples!\nThe package haven has functions to read and write data in formats used by SAS and SPSS\n\n\n\n\n\n\n\nTip\n\n\n\nTo keep a project organized, it’s good practice to\n\nStore original, raw data in a dedicated directory like data-raw and never modify it!\nRead it, clean it, and store a clean version of your data in data\n\nThat way, you should always your original data, your final data, and most importantly: Reproducible R code you can share with others that explains how to get from point A to point B!"
  },
  {
    "objectID": "03-tabular-data.html#excursion-packages",
    "href": "03-tabular-data.html#excursion-packages",
    "title": "3: Tabular Data",
    "section": "Excursion: Packages",
    "text": "Excursion: Packages\nBefore we move on, it’s time to take a look at this open source ecosystem we mentioned in the beginning. In R, this mostly means we can install packages. A package is a collection of functions and sometimes other objects which we can use for additional capabilities, and lets us benefit from other people’s work such that we don’t have to reinvent the wheel every time we do an analysis.\nWe can install packages using either RStudio’s “Packages” pane to the right, or we can use R functions directly.\nFor example, there is a package called \"readxl\" which allows us to Excel files (.xlsx), and we can install it like this:\n\ninstall.packages(\"readxl\")\n\nWe can then load the package using the library() function.\n\nlibrary(readxl)\n\nWe can now use functions from the package, and if we don’t know where to start, usually ?readxl is a good entrypoint.\nKeep in mind:\n\nYou have to install a package once into your package “library”\nYou have to load the package every time you restart R\nYou should occasionally update your installed packages using update.packages(ask = FALSE).\n\nAs an example for what we would use readxl for, let’s read an example dataset stored on data-raw in this folder in the .xlsx format.\n\nexample_df &lt;- readxl::read_excel(path = \"data-raw/example.xlsx\")\n\nHere, the function read_excel() is provided by the package readxl and only available when that package is installed and loaded! An error message like\ncould not find function \"read_excel\"\nindicated that you either have not loaded the required package or maybe mistyped the function name.\n\n\n\n\n\n\nNote\n\n\n\nOnce a package is installed, it is also possible to use one of its functions without loading it beforehand by using the :: syntax, like readxl::read_excel()\nWe won’t do that here yet, but in the wild you might find people referring to a function in the format somePackage::some_fun() to clarify they mean some_fun() from the package somePackage!\n\n\n\nYour Turn\nWe will now move on to using more packages, which of course first need installation. Unless you have already done so, install the following packages:\n\n“tidyverse”\n“gapminder”\n“gtsummary”\n“table1”\n“ggstatsplot”\n“ggthemes”\n“readr”\n\nAlternatively you can install the package pak first, and then install the packages above using pkg_install():\n\nlibrary(pak)\npkg_install(\"tidyverse\")\n\npak should be a bit faster and depending on your operating system also more robust, and it brings a few features not relevant yet.\nIf you use a Linux distribution like Ubuntu, pak can save you a lot of annoyances.\nIn any case, this might take a moment!"
  },
  {
    "objectID": "03-tabular-data.html#knowing-your-data",
    "href": "03-tabular-data.html#knowing-your-data",
    "title": "3: Tabular Data",
    "section": "Knowing Your Data",
    "text": "Knowing Your Data\nAs mentioned, accessing tabular data is a bit more complex than it is for vectors, and in the next section we will learn about convenient tools for this case. However, there are some common built-in tools that R provides for this which you should be at least aware of.\nWe’ll start with a new dataset from one of the packages you just installed: gapminder This dataset is based on the Gapminder data, and also part of Hans Rosling’s almost 20 year old TED talk.\nFirst we load the data which in this case means to just load the gapminder package to access the dataset with the same name (confusingly so)\n\nlibrary(gapminder)\ngapminder\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\nWe can also view the dataset in RStudio with View(), and look at its documentation with ?:\nView(gapminder)\n?gapminder\nTo see the number of rows and columns, we can use nrow(), ncol(), or dim().\n\nnrow(gapminder)\n\n[1] 1704\n\nncol(gapminder)\n\n[1] 6\n\ndim(gapminder)\n\n[1] 1704    6\n\n\nWe often want to see the first or last few rows using head() and tail() (note: these also work on vectors!)\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\ntail(gapminder)\n\n# A tibble: 6 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1982    60.4  7636524      789.\n2 Zimbabwe Africa     1987    62.4  9216418      706.\n3 Zimbabwe Africa     1992    60.4 10704340      693.\n4 Zimbabwe Africa     1997    46.8 11404948      792.\n5 Zimbabwe Africa     2002    40.0 11926563      672.\n6 Zimbabwe Africa     2007    43.5 12311143      470.\n\n\nWe can also use str() to get a basic overview of the data, including each variables type:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nDon’t forget we can also refer to the documentation using ?gapminder to learn about what each variable means!\nThere is also something new there: A type of data we have not encountered before: The factor! factors are for categorical data, particularly the kind where we know beforehand how many different categories there are and what they are called.\nA quick example:\n\nfruit &lt;- factor(c(\"apple\", \"lemon\", \"apple\"))\nfruit\n\n[1] apple lemon apple\nLevels: apple lemon\n\nlevels(fruit)\n\n[1] \"apple\" \"lemon\"\n\n\nWe can set the levels of a factor manually or change them later.\nA factor can have a level that does not appear on the data, but it will “know” that there is an extra category, which helps us keep an overvoew on what we expect!\n\nfruit &lt;- factor(\n   c(\"orange\", \"apple\", \"apple\", \"orange\", \"apple\", \"orange\"), \n   levels = c(\"apple\", \"banana\", \"orange\")\n)\nfruit\n\n[1] orange apple  apple  orange apple  orange\nLevels: apple banana orange\n\nlevels(fruit)\n\n[1] \"apple\"  \"banana\" \"orange\"\n\n\nThe table() function gives us a simple frequency table of the data, and since it expects there to be \"banana\", it shows us a frequency of 0:\n\ntable(fruit)\n\nfruit\n apple banana orange \n     3      0      3 \n\nfruit_char &lt;- c(\"orange\", \"apple\", \"apple\", \"orange\", \"apple\", \"orange\")\n\ntable(fruit_char)\n\nfruit_char\n apple orange \n     3      3 \n\n\nfactors are like characters but with additional information stored in them, and dealing with them can be a bit counter-intuitive. For now, we’re happy with knowing that they exists and that they are useful for categorical data!\nIn gapminder, there are two factor variables as we have seen using str(): country and continent.\nWe can use the aforementioned table() to get a broad overview of what we are dealing with\n\ntable(gapminder$continent)\n\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nWe will get a better overview later, but for now we’ll practice the basics for a moment\n\nYour Turn\nUsing the gapminder data, try to find out the following:\n\nSelect the variables country, pop and lifeExp\nFilter the dataset to the year 2007\nFor the country of Mauritius, what is the population in the year 1997?\nHow many different countries are in the dataset?\n\nHint: The function unique() is similar to levels() for factors, but more general – both can be combined with length()!"
  },
  {
    "objectID": "05-ggplot2.html",
    "href": "05-ggplot2.html",
    "title": "5: ggplot2",
    "section": "",
    "text": "Building on the previous section, this is where things get visual!\nFinally!\nWe’ll start by loading the tidyverse and gapminder for the data:\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(gapminder)"
  },
  {
    "objectID": "05-ggplot2.html#introducing-ggplot2",
    "href": "05-ggplot2.html#introducing-ggplot2",
    "title": "5: ggplot2",
    "section": "Introducing: ggplot2",
    "text": "Introducing: ggplot2\nAs far as data visualization goes, ggplot2 is probably the most popular package in the R ecosystem.\nIt’s an implementation of the “Grammar of graphics”, hence the gg, and it’s well known for its versatility. We can create the most common types of plots with relative ease, including\n\nScatterplots\nBoxplots\nHistograms\nBarcharts (horizontal or vertical)\n\nA ggplot is made up of layers, which are added to the plot with + and can be modified with + as well.\nThink of building a ggplot as stacking layers on top of each other, and modifying the layers as you go.\nLet’s start with an example of a scatterplot:\n\nggplot(gapminder)\n\n\n\n\n\n\n\n\nThis doesn’t really do anything yet – it’s the empty layer. But at least we specific a dataset.\n\nggplot(gapminder, mapping = aes(x = lifeExp, y = gdpPercap))\n\n\n\n\n\n\n\n\nHere we used aes() to declare a mapping or aesthetics between the variables lifeExp to the x-axis and gdpPercap to the y-axis. This is the crucial step to creating a plot! But we have not decided what the geometric object is going to be, which is the geom_ part of the plot.\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThis already looks like a scatterplot!\nWe might want to adjust the point size, color, etc. – that’s the job of the geom!\n\nggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +\n  geom_point(size = 5, color = \"#206b0d\", alpha = 0.1)\n\n\n\n\n\n\n\n\nWe can save the plot to a variable p and then modify it afterwards:\n\np &lt;- ggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +\n  geom_point(size = 3, color = \"blue\", alpha = 0.25)\n\np\n\n\n\n\n\n\n\n\nFor example, we can try out some themes, for examples those provided by the ggthemes package:\n\nlibrary(ggthemes)\n\np + theme_calc()\n\n\n\n\n\n\n\np + theme_economist()\n\n\n\n\n\n\n\np + theme_base()\n\n\n\n\n\n\n\np + theme_excel()\n\n\n\n\n\n\n\np + theme_excel_new()\n\n\n\n\n\n\n\np + theme_stata()\n\n\n\n\n\n\n\n\n\n# Default theme, but with bigger text\np + theme_gray(base_size = 14)\n\n\n\n\n\n\n\n# Lukas' \"go to\" theme :)\np + theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\nPlaying around with ggplot themes is usually a great way to spend an afternoon, so we’ll leave it at that for now, but you can find more info at the ggthemes website or ggplot2’s documentation at https://ggplot2.tidyverse.org.\n\nCore geom_s\nFor now we will keep the colors and theming simple and focus on the most common types of plots you’ll likely want to create:\n\nScatterplots -&gt; geom_point()\nBoxplots -&gt; geom_boxplot()\nHistograms -&gt; geom_histogram()\nBarcharts (horizontal or vertical) -&gt; geom_col() or geom_bar()\n\nAs a general tip, it’s often useful to use tidyverse verbs as “pre-processing” before piping data into ggplot(), that way you can focus on the plot itself after you have prepared your data to look like you need it for the type of plot you want.\n\nScatterplots\nWe have seen an example scatterplot before, but given the data at hand it’s probably more useful to focus on a specific year at a time, which is easiest to do with a filter() step beforehand\n\np &lt;- gapminder |&gt;\n  filter(year == 1987) |&gt;\n  ggplot(aes(x = lifeExp, y = gdpPercap)) +\n  geom_point()\n\n\n\n\n\n\n\nNote\n\n\n\nIf you get confused between using |&gt; and +, know that you are not alone!\nLuckily, the error messages are informative.\n\n\nA more advanced examples would be to add a linear regression line, but in this case we can already see that a linear fit is not appropriate here. We can still add a regression line though, by adding new layer:\n\np +\n  geom_smooth()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\ngeom_smooth() will add a general trendline, which could be a linear model or a loess curve or a GAM – if you want to explicitly add a linear trendline, use geom_smooth(method = \"lm\"), but beware that this is not always approriate!\n\np +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nIn some cases, a scatterplot is maybe not well suited, for example if the x-variable is technically numeric but effectively categorical, like year in this case:\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = gdpPercap)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThat’s where boxplots are useful!\n\n\nBoxplots\nSo a boxplot where each year gets its own box should be straight forward, yes?\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = gdpPercap)) +\n  geom_boxplot()\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\n\n\n\n\n\n\n\nUnfortunately, no. Since year is technically numeric, we have two ways to deal with it and let ggplot now that year should be used as a grouping variable, and one of which the error message already suggested:\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = gdpPercap, group = year)) +\n  geom_boxplot()\n\n\n\n\n\n\n\ngapminder |&gt;\n  ggplot(aes(x = year, y = gdpPercap, group = year)) +\n  geom_boxplot() +\n  scale_y_log10()\n\n\n\n\n\n\n\n\nHere group is used within aes() as a special mapping that tells ggplot that year should be used to group the data into boxplots without us needing to otherwise modify the data.\nHowever, if we wanted, we could also recode year to be a factor variable just for this one case, which should alos get us where we need:\n\ngapminder |&gt;\n  mutate(year = as.factor(year)) |&gt;\n  ggplot(aes(x = year, y = gdpPercap)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\ngapminder |&gt;\n  filter(year == 1997) |&gt;\n  ggplot(aes(x = continent, y = pop)) +\n  geom_boxplot(fill = \"darkred\", alpha = .25) +\n  scale_y_log10(labels = scales::number_format()) +\n  theme_minimal(base_size = 14) +\n  theme(\n    axis.title = element_text(hjust = 0, size = unit(13, \"mm\"))\n  )\n\n\n\n\n\n\n\n\n\n\nHistograms\nA histogram is technically a type of barchart, but since it’s so common and requires binning the data, it get’s a special place within ggplot.\n\np &lt;- gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = lifeExp))\n  \np +\n  geom_histogram(color = \"black\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nIf the defaults are not suited well, we can adjust the bins with binwidth (in this case the number of years on the x-axis) or bins to specify the number of bins in total. Another thing we’ll add is the color argument, which for a barchart changes the outline color of the bars and let’s us see the bars better. There’s also fill, which changes the fill color of the bars.\n\np + geom_histogram(binwidth = 5, color = \"black\") \n\n\n\n\n\n\n\np + geom_histogram(binwidth = 10, color = \"black\")\n\n\n\n\n\n\n\np + geom_histogram(bins = 10, color = \"black\")\n\n\n\n\n\n\n\n\n\n\nBarcharts\nSometimes people use different names vor horizontal or vertical bar charts, and confusingly enough ggplot only differentiates between “column” charts and “bar” charts, both of which can have either orientation.\nLet’s settle on a simple goal: the number of observations (countries) per continent in 2007.\nFor practice, let’s first calculate that using dplyr verbs and use the n() helper function which just counts the number of rows (in a group):\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  group_by(continent) |&gt;\n  summarize(n = n())\n\n# A tibble: 5 × 2\n  continent     n\n  &lt;fct&gt;     &lt;int&gt;\n1 Africa       52\n2 Americas     25\n3 Asia         33\n4 Europe       30\n5 Oceania       2\n\n\nThis combination of group_by() |&gt; summarize(n = n()) is so common that ggplot has a shortcut for it: count():\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  count(continent)\n\n# A tibble: 5 × 2\n  continent     n\n  &lt;fct&gt;     &lt;int&gt;\n1 Africa       52\n2 Americas     25\n3 Asia         33\n4 Europe       30\n5 Oceania       2\n\n\nBut we digress – let’s get charting:\ngeom_bar() behaves similar to geim_histogram(), but for categorical variables. It doesn’t do any binning, and just counts the number of observations for each group defined by the variable passed to x:\n\np &lt;- gapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(x = continent)) +\n  geom_bar()\n\np\n\n\n\n\n\n\n\n\nIf we want to change orientation, it’s easy to do, but there are multiple ways!\nVersion 1: Use coord_flip():\n\np + coord_flip()\n\n\n\n\n\n\n\n\nVersion 2: Pass the variable to y rather than x:\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggplot(aes(y = continent)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe reason there are multiple ways to do that is because early on, only version 1 was possible, and version 2 was only made possible relatively recently.\nThere are many things like that in ggplot2, so please don’t be afraid to try out different ways of doing things — unless you get a warning or error message, it’s probably fine if it gets you what you want, and when in doubt there’s always good onlie documentation or tutorials.\n\n\nBut what about geom_col?\nWell, sometimes we just want to make a barchart without ggplot doing the counting for us!\nMaybe we want percentages rather than absolute numbers on the y-axis for example. That’s what geom_col() is for: It let’s us define x and y variables.\nLet’s say we want the same basic plot as before, but with percentages:\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  group_by(continent) |&gt;\n  summarize(\n    n = n(),\n    percent = n / n_distinct(gapminder$country)\n  ) |&gt;\n  ggplot(aes(x = continent, y = percent)) +\n  geom_col()\n\n\n\n\n\n\n\n\nNote that we need to refer to the full dataset to get the total number of countries here in order to calculate the percentages, because after we have used group_by(), all operations are limited to the group we are currently working with!\nSo as far as the plot goes, this is technically correct, but not very nice to look at.\nLet’s use this as a starting point to make our plots a little nicer!\n\n\n\nYour turn: Customization\nIf we wanted to use this plot in a publication or presentation, we probably should make a few tweaks.\nLet’s specify a few “wants”, together with a few hints on how to achieve them, and experiment with them!\n\nChange the axis labels to something more human-readable\nAdd a title, subtitle, and caption to better describe what we’re seeing\nMaybe a nicer fill color than gray? Pick one you like from https://www.color-hex.com/\nReorder the columns from highest to lowest\n\nAdvanced:\n\nThe y-axis labels would probably look better as “30%” rather than “0.3”\n\nHints:\n\nLook at the documentation at https://ggplot2.tidyverse.org/reference/index.html\nlabs() should suffice for 1 and 2!\nThe function color() lists all color names R knows, otherwise you can use RGB codes like #CBDFBD if you google “RGB color picker” you’ll find a lot of examples!\nReordering the continents is as easy as using reorder()!\n\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  group_by(continent) |&gt;\n  summarize(\n    n = n(),\n    percent = n / n_distinct(gapminder$country)\n  ) |&gt;\n  ggplot(aes(x = reorder(continent, desc(percent)), y = percent)) +\n  geom_col(fill = \"#63AEE1\") +\n  scale_y_continuous(\n    breaks = seq(0, 1, by = 0.1),\n    labels = scales::label_percent()\n  ) +\n  labs(\n    title = \"Countries per Continent\",\n    subtitle = \"Data from Gapminder\",\n    x = \"Continents in Gapminder\",\n    y = \"Countries per Continent\",\n    caption = \"Data as of 2007\"\n  )"
  },
  {
    "objectID": "05-ggplot2.html#advanced-ggplot2",
    "href": "05-ggplot2.html#advanced-ggplot2",
    "title": "5: ggplot2",
    "section": "Advanced ggplot2",
    "text": "Advanced ggplot2"
  },
  {
    "objectID": "05-ggplot2.html#but-isnt-there-an-easier-way",
    "href": "05-ggplot2.html#but-isnt-there-an-easier-way",
    "title": "5: ggplot2",
    "section": "“But isn’t there an easier way?”",
    "text": "“But isn’t there an easier way?”\nYes, there is!\nggplot2 is all about the building blocks, and for many common scenarios it’s cumbersome to always stack the same components on top of each other.\nLuckily there are tons of R packages either extending ggplot2 or providing wrappers for common needs.\nOne of those wrapper packages is ggstatsplot, which you should have installed earlier in the course but which we haven’t used yet.\nAs the title suggest this package is primarily aimed towards statistical comparisons, but it can also be used for exploratory analyses.\n\nlibrary(ggstatsplot)\n\nYou can cite this package as:\n     Patil, I. (2021). Visualizations with statistical details: The 'ggstatsplot' approach.\n     Journal of Open Source Software, 6(61), 3167, doi:10.21105/joss.03167\n\n\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggbetweenstats(\n    x = continent, y = lifeExp,\n    xlab = \"Continent\",\n    ylab = \"Life Expectancy (years)\",\n    title = \"Life Expectancy by Continent (2007)\"\n  )\n\n\n\n\n\n\n\n\nWe can disable some of the statistical information by using bf.message = FALSE and results.subtitle = FALSE:\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n  ggbetweenstats(\n    x = continent, y = lifeExp,\n    xlab = \"Continent\",\n    ylab = \"Life Expectancy (years)\",\n    bf.message = FALSE, \n    results.subtitle = FALSE,\n    title = \"Life Expectancy by Continent (2007)\"\n  )\n\n\n\n\n\n\n\n\nRecreating something like this with ggplot2 is a bit of a chore, but ggstatsplot makes it a lot easier! Here’s an incomplete attempt of recreating the above plot:\n\ngapminder |&gt;\n  filter(year == 2007) |&gt;\n    ggplot(aes(x = continent, y = lifeExp)) +\n    geom_violin() +\n    geom_boxplot(alpha = .1, width = 0.4) +\n    geom_point(\n      aes(fill = continent),\n      shape = 21, size = 3, stroke = 0, alpha = .4,\n      position = position_jitter(width = 0.1)\n    ) +\n    stat_summary(fun = mean, geom = \"point\", shape = 21, size = 3, color = \"black\", fill = \"darkred\") +\n    labs(\n      title = \"Life Expectancy by Continent (2007)\",\n      subtitle = \"Data via Gapminder\",\n      x = \"Continent\",\n      y = \"Life Expectancy (years)\"\n    ) +\n    theme_minimal(base_size = 14) +\n    theme(legend.position = \"none\")"
  }
]