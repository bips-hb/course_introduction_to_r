---
title: "4: The Tidyverse"
format: 
  html:
    toc: true
editor: visual
---

The [**Tidyverse**](https://www.tidyverse.org/) is a collection of R packages created and maintained by the same group of people, largely from the same company that also created RStudio: Posit!

The Tidyverse is designed to make data science easier, more efficient, and more fun.\
It is built around the idea of *tidy data*, which in essence just means that data is organized in a way that makes it easy to work with.
In the previous section we have already heard the two core properties of tidy data:

1.  Each **column** of your data is a **variable**
2.  Each **row** of your data is an **observation**

![From R4DS Chapter 5](https://r4ds.hadley.nz/images/tidy-1.png)

And the tidyverse is created in part to make it easy to get your data in that shape and work with data in that shape.
If `R` in general is a language, then we can think of "tidyverse" as a kind of dialect â€” it's still R, but it has a specific context and use case and it is spoken by a community of people roughly doing similar kinds of data analysis.

Let's start by loading the `tidyverse` meta-package.

```{r load-tiyverse}
library(tidyverse)
```

You'll see a lot of information there, and that's nothing to worry about.
What happened here is the following:

1.  The `tidyverse` package's main purpose is to load *other* packages, like `dplyr`, `ggplot2`, `tidyr`, ... -\> These are the *actual* tidyverse packages that provide the functionality we want!
2.  It warns you about **conflicting function names**, like `filter` and `lag`. There are built-in functions in R of the same name that do very different things than they do in the tidyverse, and for the most part that is not a problem **unless** you try to use the function `filter` from the `dplyr` package but forgot to load `dplyr` beforehand!

Note that in the tidyverse, the `tibble` enhances the `data.frame`!\
Tibbles are simialr to data.frames, but they look nice and avoid some potentially confusing issues.\
For now we don't need to know more, but fur future reference you should not worry when you encounter a `tibble`!

## Tidyverse Basics: Pipes and Verbs

We start by loading the `gapminder` package again for its dataset, just like we did before, but now we can `glimpse` it rather than `str` it:

```{r load-gapminder}
library(gapminder)

glimpse(gapminder)
```

Remember how it was somewhat awkward to select specific rows and columns from the `data.frame` before?

For example, here is "country, life expectancy and population for all Asian countries in 1967" in *base R* syntax:

```{r base-filter-select}
gapminder[gapminder$continent == "Asia" & gapminder$year == 1967, 
          c("country", "lifeExp", "pop")]
```

In the `tidyverse`, or specifically `dplyr` syntax, we would write it like this:

```{r tidy-filter-select}
gapminder |>
  filter(continent == "Asia" & year == 1967) |>
  select(country, lifeExp, pop)
```

What happened here?
Let's dissect this one by one:

1.  We started with the `gapminder` dataset, and *then*, via the "pipe" `|>`,
2.  We used `filter()` to select **rows** using a logical expression, and *then*
3.  We used `select()` to select specific **columns** (without having to quote than with `"`!)

This is a combination of the pipe-syntax, which passes things down to the next function, and the most common tidyverse **verbs** that are at the core of most data operations.

The pipe `|>` works everywhere in R, and `x |> foo()` is just a different way to write `foo(x)`:

```{r}
x <- 1:10

length(x)
x |> length()
```

This becomes really powerful once we *chain* many functions.\
Consider a made-up example:

``` r
x |>
  do_the_thing() |>
  do_the_other_thing() |>
  twist_it() |>
  shake_it_around() |>
  do_a_little_dance()
```

Here you can read the code top to bottom, and understand the sequence of events just by following the code.
Consider what this would look like without the `|>`:

``` r
do_a_little_dance(shake_it_around(twist_it(do_the_other_thing(do_the_thing(x)))))
```

Or, with a little more indentation:

``` r
do_a_little_dance(
  shake_it_around(
    twist_it(
      do_the_other_thing(
        do_the_thing(x)
      )
    )
  )
)
```

You would have to read the code "inside out" to follow what's happening here.

Another alternative would be to create new variables or overwrite the previous one, like so:

``` r
x <- do_the_thing(x)
x <- do_the_other_thing(x)
x <- twist_it(x)
x <- shake_it_around(x) 
x <- do_a_little_dance(x)
```

The pipe syntax might take some getting used to, but usually people find it quite intuitive after a while.

Please keep in mind though that *not everything* has to be translated into a pipe-syntax, and that there are always other ways to do the same thing.

## Common Verbs (I)

All verbs take a `data.frame` (or `tibble`, which are almost the same thing) as their first argument, and the most important ones are:

-   `select()`: Selects variables (**columns**) of the dataset (without quoting them with `" "`)
-   `filter()`: Filters the dataset to only the **rows** matching the condition(s) inside
-   `arrange()`: **Sorts** the dataset by a variable like `pop`, optionally in decreasing order by using `desc()` inside.

We start with `select()`, which is fairly self-explanatory and corresponds to using `[ ]` with column names or indices as we've seen before

```{r}
gapminder |>
  select(year, country, pop)

# If we happen to know the variable indices, this also works
gapminder |>
  select(3, 1, 5)
```

In cases where we pick out individual variables, we often want to sort by one as well:

```{r}
gapminder |>
  select(year, continent, country) |>
  arrange(year)
```

Or sorting descendingly with the `desc()` helper function:

```{r}
gapminder |>
  select(year, continent, country) |>
  arrange(desc(year))
```

For a numeric variable like `year` we could also just sort by a negative of the variable:

```{r}
gapminder |>
  select(year, continent, country) |>
  arrange(-year)
```

But `desc()` has the benefit of also working for `character` (sorted alphabetically) or `factor` variables (sorted by their `levels`), which makes `desc()` applicable in more cases.

```{r}
gapminder |>
  select(year, continent, country) |>
  arrange(desc(continent))
```

```{r}
gapminder97 <- gapminder |>
  filter(year == 1997) |>
  arrange(pop)
```

Note that in `filter()` you use logical expressions as we've seen in section 2!\
You can combine multiple conditions by passing them as separate arguments with `,` which inside `filter()` is the same as using the logical `AND` with `&`:

```{r}
# Explicitly using AND & to combine year and country conditions
gapminder |>
  filter(year == 1997 & country == "Iceland")

# Identical:
gapminder |>
  filter(
    year > 1990, 
    country == "Iceland"
  )
```

As a more advanced example, we can use `select()`-helper functions to select variables that start with a certain pattern or contain a certain word:

```{r}
gapminder |>
  select(starts_with("c"))

gapminder |>
  select(contains("gdp"))

gapminder |>
  select(ends_with("p"))
```

### Your turn

1.  Select the country and life expectancy variables for the year 1952
2.  Subset the dataset to only contain data recorded after 1990
3.  Subset the dataset to only contain data in the 1970s for Ecuador

```{r tidyverse-select-filter1}
gapminder |>
  filter(year == 1952) |>
  select(country, lifeExp)
```

```{r tidyverse-select-filter2}
gapminder |>
  filter(year > 1990)
```

```{r tidyverse-select-filter3a}
gapminder |>
  filter(
    year >= 1970, year <= 1979,
    country == "Ecuador"
  )

gapminder |> 
  filter(year > 1969 & year < 1980) |> 
  filter(country == "Ecuador")

```

```{r tidyverse-select-filter3b}
gapminder |>
  filter(
    between(year, 1970, 1979),
    country == "Ecuador"
  )
```

Hint: When you select *and* filter, keep in mind the order of operations!\
You can't filter by a variable which you have de-selected beforehand.

## Common Verbs (II)

So far we have only selected specific subsets of our data, but now we want to actually *do* something!
For that, we have two main options:

1.  Creating a new variable
2.  Calculating some summary statistic like the mean or median

-   `mutate()`: Creates a **new variables**, e.g. create `pop_m` as the variable `pop` divided by 1,000,000
-   `summarize()`: Often used together with `group_by()`, this **summarizes** the dataset by calculating something for each group declared by `group_by()`
-   `group_by()`: Declares the dataset to be **grouped** by the values of variable like `continent` -- we will see examples next!

```{r}
gapminder <- gapminder |>
  mutate(pop_m = pop / 1e6)

gapminder |>
  mutate(pop = pop / 1e6)

```

```{r}

gapminder |>
  mutate(pop_mean = mean(pop))

gapminder |>
  summarize(
    pop_mean = mean(pop)
  )
```

```{r}
gapminder |>
  group_by(continent)

gapminder |>
  group_by(continent) |>
  summarize(mean_pop = mean(pop))
```

Or multiple things combined:

```{r gapminder-piping}
gapminder |>
  filter(year >= 1980) |>
  mutate(pop_m = pop / 1e6) |>
  # group_by(continent) |>
  summarize(
    mean_pop_m = mean(pop_m),
    median_pop_m = median(pop_m),
    min_pop_m = min(pop_m),
    max_pop_m = max(pop_m)
  )
```

### Your turn

0.  install the tidyverse & load with `library(tidyverse)`
1.  Explain in words what has happened in the previous code chunk.
2.  What happens if you use `summarize()` without `group_by()`?
3.  Use `summarise()` and the helpful `n_distinct()` to calculate the number of countries per continent
4.  Create a new variable `gdpPercap_m` as the variable `gdpPercap` divided by 1 Million and rounded to 2 decimal places

```{r tidyverse-mutate-summarize3}
gapminder |>
  group_by(continent) |>
  summarize(
    num_countries = n_distinct(country),
    n = n()
  )

gapminder |>
  filter(continent == "Oceania") |>
  group_by(country) |>
  summarize(
    n = n(),
    num_years = n_distinct(year)
  )

```

```{r tidyverse-mutate-summarize4}
gapminder |>
  mutate(gdpPercap_m = round(gdpPercap / 1e3, digits = 2))

gapminder |>
  mutate(gdpPercap_m = gdpPercap / 1e6) |>
  mutate(gdpPercap_m = round(gdpPercap_m, digits = 2))
```

## Other Useful Verbs

### Changing Shapes

A more advanced topic but often needed for data manipulation is reshaping your data using the `tidyr` package.

This might be best explained by example.\
Say we want to calculate the difference in life expectancy between 1952 and 2007 for each country and continent, but using the verbs we've seen so far we can't do that with a simple `mutate()`.
We can instead use `pivot_wider()` which is a function that takes a "long" dataset and pivots it into a "wide" dataset:

```{r}
gapminder |>
  filter(year %in% c(1952, 2007)) |>
  pivot_wider(
    id_cols = c(country, continent), 
    names_from = year, 
    values_from = lifeExp,
    names_prefix = "lifeExp_"
  ) |>
  mutate(change_life_exp = lifeExp_2007 - lifeExp_1952)
```

### Combining Things

Sometimes it's useful to combined datasets by rows or columns:

`bind_rows()` is for *rows*, similar to base R's `rbind()` but has some advantages

```{r}
gapminder52 <- gapminder |>
  filter(year == 1952)

gapminder07 <- gapminder |>
  filter(year == 2007)

bind_rows(gapminder52, gapminder07)
```

`bind_cols()` combined datasets by *columns*, similar to base R's `cbind()`.\
For example, here is a way to create to year-specific variables similar to the `pivot_wider()` example above

```{r}
gapminder52 <- gapminder |>
  filter(year == 1952) |>
  rename(lifeExp_1952 = lifeExp)

gapminder07 <- gapminder |>
  filter(year == 2007) |>
  select(lifeExp) |>
  rename(lifeExp_2007 = lifeExp)

bind_cols(gapminder52, gapminder07) |>
  select(starts_with("lifeExp"))
```

## Introducing: `ggplot2`

As far as data visualization goes, `ggplot2` is probably the most popular package in the R ecosystem.\
It's an implementation of the "Grammar of graphics", hence the `gg`, and it's well known for its versatility.
We can create the most common types of plots with relative ease, including

-   Scatterplots
-   Boxplots
-   Histograms
-   Barcharts (horizontal or vertical)

A ggplot is made up of **layers**, which are added to the plot with `+` and can be modified with `+` as well.\
Think of building a ggplot as stacking layers on top of each other, and modifying the layers as you go.

Let's start with an example of a scatterplot:

```{r}
ggplot(gapminder)
```

This doesn't really do anything yet -- it's the *empty* layer.
But at least we specific a dataset.

```{r}
ggplot(gapminder, mapping = aes(x = lifeExp, y = gdpPercap))
```

Here we used `aes()` to declare a *mapping* or *aesthetics* between the variables `lifeExp` to the x-axis and `gdpPercap` to the y-axis.
This is the crucial step to creating a plot!
But we have not decided what the *geometric* object is going to be, which is the `geom_` part of the plot.

```{r}
ggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +
  geom_point()
```

This already looks like a scatterplot!\
We might want to adjust the point size, color, etc. -- that's the job of the `geom`!

```{r}
ggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +
  geom_point(size = 5, color = "#206b0d", alpha = 0.1)
```

We can save the plot to a variable `p` and then modify it afterwards:

```{r}
p <- ggplot(gapminder, aes(x = lifeExp, y = gdpPercap)) +
  geom_point(size = 3, color = "blue", alpha = 0.25)

p
```

For example, we can try out some themes, for examples those provided by the `ggthemes` package:

```{r}
library(ggthemes)

p + theme_calc()
p + theme_economist()
p + theme_base()
p + theme_excel()
p + theme_excel_new()
p + theme_stata()
```

```{r}
# Default theme, but with bigger text
p + theme_gray(base_size = 14)
# Lukas' "go to" theme :)
p + theme_minimal(base_size = 14)
```

Playing around with ggplot themes is usually a great way to spend an afternoon, so we'll leave it at that for now, but you can find more info at the [ggthemes](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) website or ggplot2's documentation at https://ggplot2.tidyverse.org.

### Core `geom_`s

For now we will keep the colors and theming simple and focus on the most common types of plots you'll likely want to create:

-   Scatterplots -\> `geom_point()`
-   Boxplots -\> `geom_boxplot()`
-   Histograms -\> `geom_histogram()`
-   Barcharts (horizontal or vertical) -\> `geom_col()` or `geom_bar()`

As a general tip, it's often useful to use tidyverse verbs as "pre-processing" before piping data into `ggplot()`, that way you can focus on the plot itself after you have prepared your data to look like you need it for the type of plot you want.

#### Scatterplots

We have seen an example scatterplot before, but given the data at hand it's probably more useful to focus on a specific year at a time, which is easiest to do with a `filter()` step beforehand

```{r}
p <- gapminder |>
  filter(year == 1987) |>
  ggplot(aes(x = lifeExp, y = gdpPercap)) +
  geom_point()
```

::: callout-note
If you get confused between using `|>` and `+`, know that you are not alone!\
Luckily, the error messages are informative.
:::

A more advanced examples would be to add a linear regression line, but in this case we can already see that a linear fit is not appropriate here.
We can still add a regression line though, by adding new layer:

```{r}
p +
  geom_smooth()
```

`geom_smooth()` will add a general trendline, which could be a linear model or a loess curve or a GAM -- if you want to explicitly add a linear trendline, use `geom_smooth(method = "lm")`, but beware that this is not always approriate!

```{r}
p +
  geom_smooth(method = "lm", color = "red", se = FALSE)
```

In some cases, a scatterplot is maybe not well suited, for example if the `x`-variable is *technically* numeric but *effectively* categorical, like `year` in this case:

```{r}
gapminder |>
  ggplot(aes(x = year, y = gdpPercap)) +
  geom_point()
```

That's where boxplots are useful!

#### Boxplots

So a boxplot where each year gets its own box should be straight forward, yes?

```{r}
gapminder |>
  ggplot(aes(x = year, y = gdpPercap)) +
  geom_boxplot()
```

Unfortunately, no.
Since `year` is technically numeric, we have two ways to deal with it and let ggplot now that `year` should be used as a grouping variable, and one of which the error message already suggested:

```{r}
gapminder |>
  ggplot(aes(x = year, y = gdpPercap, group = year)) +
  geom_boxplot()

gapminder |>
  ggplot(aes(x = year, y = gdpPercap, group = year)) +
  geom_boxplot() +
  scale_y_log10()
```

Here `group` is used within `aes()` as a special mapping that tells `ggplot` that `year` should be used to group the data into boxplots without us needing to otherwise modify the data.

However, if we wanted, we could also recode `year` to be a factor variable just for this one case, which should alos get us where we need:

```{r}
gapminder |>
  mutate(year = as.factor(year)) |>
  ggplot(aes(x = year, y = gdpPercap)) +
  geom_boxplot()

```

```{r}
gapminder |>
  filter(year == 1997) |>
  ggplot(aes(x = continent, y = pop)) +
  geom_boxplot(fill = "darkred", alpha = .25) +
  scale_y_log10(labels = scales::number_format()) +
  theme_minimal(base_size = 14) +
  theme(
    axis.title = element_text(hjust = 0, size = unit(13, "mm"))
  )

```

#### Histograms

A histogram is technically a type of barchart, but since it's so common and requires binning the data, it get's a special place within ggplot.

```{r}
p <- gapminder |>
  filter(year == 2007) |>
  ggplot(aes(x = lifeExp))
  
p +
  geom_histogram(color = "black")
```

If the defaults are not suited well, we can adjust the bins with `binwidth` (in this case the number of years on the x-axis) or `bins` to specify the number of bins in total.
Another thing we'll add is the `color` argument, which for a barchart changes the outline color of the bars and let's us see the bars better.
There's also `fill`, which changes the fill color of the bars.

```{r}
p + geom_histogram(binwidth = 5, color = "black") 
p + geom_histogram(binwidth = 10, color = "black")
p + geom_histogram(bins = 10, color = "black")
```

#### Barcharts

Sometimes people use different names vor horizontal or vertical bar charts, and confusingly enough ggplot only differentiates between "column" charts and "bar" charts, both of which can have either orientation.

Let's settle on a simple goal: the number of observations (countries) per continent in 2007.\
For practice, let's first calculate that using `dplyr` verbs and use the `n()` helper function which just counts the number of rows (in a group):

```{r}
gapminder |>
  filter(year == 2007) |>
  group_by(continent) |>
  summarize(n = n())
```

This combination of `group_by() |> summarize(n = n())` is so common that ggplot has a shortcut for it: `count()`:

```{r}
gapminder |>
  filter(year == 2007) |>
  count(continent)
```

But we digress -- let's get charting:

`geom_bar()` behaves similar to `geim_histogram()`, but for categorical variables.
It doesn't do any binning, and just counts the number of observations for each group defined by the variable passed to `x`:

```{r}
p <- gapminder |>
  filter(year == 2007) |>
  ggplot(aes(x = continent)) +
  geom_bar()

p
```

If we want to change orientation, it's easy to do, but there are multiple ways!

Version 1: Use `coord_flip()`:

```{r}
p + coord_flip()
```

Version 2: Pass the variable to `y` rather than `x`:

```{r}
gapminder |>
  filter(year == 2007) |>
  ggplot(aes(y = continent)) +
  geom_bar()
```

::: callout-note
The reason there are multiple ways to do that is because early on, only version 1 was possible, and version 2 was only made possible relatively recently.\
There are many things like that in ggplot2, so please don't be afraid to try out different ways of doing things --- unless you get a warning or error message, it's probably fine if it gets you what you want, and when in doubt there's always good onlie documentation or tutorials.
:::

But what about `geom_col`?\
Well, sometimes we just want to make a barchart without ggplot doing the counting for us!\
Maybe we want percentages rather than absolute numbers on the `y`-axis for example.
That's what `geom_col()` is for: It let's us define `x` *and* `y` variables.

Let's say we want the same basic plot as before, but with percentages:

```{r}
gapminder |>
  filter(year == 2007) |>
  group_by(continent) |>
  summarize(
    n = n(),
    percent = n / n_distinct(gapminder$country)
  ) |>
  ggplot(aes(x = continent, y = percent)) +
  geom_col()
```

Note that we need to refer to the full dataset to get the total number of countries here in order to calculate the percentages, because after we have used `group_by()`, all operations are limited to the group we are currently working with!

So as far as the plot goes, this is technically correct, but not very nice to look at.\
Let's use this as a starting point to make our plots a little nicer!

### Your turn: Customization

If we wanted to use this plot in a publication or presentation, we probably should make a few tweaks.

Let's specify a few "wants", together with a few hints on how to achieve them, and experiment with them!

1.  Change the axis labels to something more human-readable
2.  Add a title, subtitle, and caption to better describe what we're seeing
3.  Maybe a nicer `fill` color than gray? Pick one you like from <https://www.color-hex.com/>
4.  Reorder the columns from highest to lowest

Advanced:

5.  The y-axis labels would probably look better as "30%" rather than "0.3"

Hints:

-   Look at the documentation at <https://ggplot2.tidyverse.org/reference/index.html>
-   `labs()` should suffice for 1 and 2!
-   The function `color()` lists all color names R knows, otherwise you can use RGB codes like `#CBDFBD` if you google "RGB color picker" you'll find a lot of examples!
-   Reordering the continents is as easy as using `reorder()`!

```{r ggplot-customization}
gapminder |>
  filter(year == 2007) |>
  group_by(continent) |>
  summarize(
    n = n(),
    percent = n / n_distinct(gapminder$country)
  ) |>
  ggplot(aes(x = reorder(continent, desc(percent)), y = percent)) +
  geom_col(fill = "#63AEE1") +
  scale_y_continuous(
    breaks = seq(0, 1, by = 0.1),
    labels = scales::label_percent()
  ) +
  labs(
    title = "Countries per Continent",
    subtitle = "Data from Gapminder",
    x = "Continents in Gapminder",
    y = "Countries per Continent",
    caption = "Data as of 2007"
  )
```

## Advanced `ggplot2`

## "But isn't there an easier way?"

Yes, there is!\
`ggplot2` is all about the building blocks, and for many common scenarios it's cumbersome to always stack the same components on top of each other.\
Luckily there are *tons* of R packages either extending ggplot2 or providing wrappers for common needs.

One of those wrapper packages is [`ggstatsplot`](https://indrajeetpatil.github.io/ggstatsplot), which you should have installed earlier in the course but which we haven't used yet.

As the title suggest this package is primarily aimed towards statistical comparisons, but it can also be used for exploratory analyses.

```{r}
library(ggstatsplot)
```

```{r}
gapminder |>
  filter(year == 2007) |>
  ggbetweenstats(
    x = continent, y = lifeExp,
    xlab = "Continent",
    ylab = "Life Expectancy (years)",
    title = "Life Expectancy by Continent (2007)"
  )
```

We can disable some of the statistical information by using `bf.message = FALSE` and `results.subtitle = FALSE`:

```{r}
gapminder |>
  filter(year == 2007) |>
  ggbetweenstats(
    x = continent, y = lifeExp,
    xlab = "Continent",
    ylab = "Life Expectancy (years)",
    bf.message = FALSE, 
    results.subtitle = FALSE,
    title = "Life Expectancy by Continent (2007)"
  )
```

Recreating something like this with `ggplot2` is a bit of a chore, but `ggstatsplot` makes it a lot easier!
Here's an incomplete attempt of recreating the above plot:

```{r}
gapminder |>
  filter(year == 2007) |>
    ggplot(aes(x = continent, y = lifeExp)) +
    geom_violin() +
    geom_boxplot(alpha = .1, width = 0.4) +
    geom_point(
      aes(fill = continent),
      shape = 21, size = 3, stroke = 0, alpha = .4,
      position = position_jitter(width = 0.1)
    ) +
    stat_summary(fun = mean, geom = "point", shape = 21, size = 3, color = "black", fill = "darkred") +
    labs(
      title = "Life Expectancy by Continent (2007)",
      subtitle = "Data via Gapminder",
      x = "Continent",
      y = "Life Expectancy (years)"
    ) +
    theme_minimal(base_size = 14) +
    theme(legend.position = "none")
```
